/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/named-placeholders";
exports.ids = ["vendor-chunks/named-placeholders"];
exports.modules = {

/***/ "(rsc)/./node_modules/named-placeholders/index.js":
/*!**************************************************!*\
  !*** ./node_modules/named-placeholders/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n// based on code from Brian White @mscdex mariasql library - https://github.com/mscdex/node-mariasql/blob/master/lib/Client.js#L272-L332\n// License: https://github.com/mscdex/node-mariasql/blob/master/LICENSE\nconst RE_PARAM = /(?:\\?)|(?::(\\d+|(?:[a-zA-Z][a-zA-Z0-9_]*)))/g, DQUOTE = 34, SQUOTE = 39, BSLASH = 92;\nfunction parse(query) {\n    let ppos = RE_PARAM.exec(query);\n    let curpos = 0;\n    let start = 0;\n    let end;\n    const parts = [];\n    let inQuote = false;\n    let escape = false;\n    let qchr;\n    const tokens = [];\n    let qcnt = 0;\n    let lastTokenEndPos = 0;\n    let i;\n    if (ppos) {\n        do {\n            for(i = curpos, end = ppos.index; i < end; ++i){\n                let chr = query.charCodeAt(i);\n                if (chr === BSLASH) escape = !escape;\n                else {\n                    if (escape) {\n                        escape = false;\n                        continue;\n                    }\n                    if (inQuote && chr === qchr) {\n                        if (query.charCodeAt(i + 1) === qchr) {\n                            // quote escaped via \"\" or ''\n                            ++i;\n                            continue;\n                        }\n                        inQuote = false;\n                    } else if (chr === DQUOTE || chr === SQUOTE) {\n                        inQuote = true;\n                        qchr = chr;\n                    }\n                }\n            }\n            if (!inQuote) {\n                parts.push(query.substring(start, end));\n                tokens.push(ppos[0].length === 1 ? qcnt++ : ppos[1]);\n                start = end + ppos[0].length;\n                lastTokenEndPos = start;\n            }\n            curpos = end + ppos[0].length;\n        }while (ppos = RE_PARAM.exec(query));\n        if (tokens.length) {\n            if (curpos < query.length) {\n                parts.push(query.substring(lastTokenEndPos));\n            }\n            return [\n                parts,\n                tokens\n            ];\n        }\n    }\n    return [\n        query\n    ];\n}\n;\nfunction createCompiler(config) {\n    if (!config) config = {};\n    if (!config.placeholder) {\n        config.placeholder = \"?\";\n    }\n    let ncache = 100;\n    let cache;\n    if (typeof config.cache === \"number\") {\n        ncache = config.cache;\n    }\n    if (typeof config.cache === \"object\") {\n        cache = config.cache;\n    }\n    if (config.cache !== false && !cache) {\n        cache = new (__webpack_require__(/*! lru-cache */ \"(rsc)/./node_modules/named-placeholders/node_modules/lru-cache/index.js\"))({\n            max: ncache\n        });\n    }\n    function toArrayParams(tree, params) {\n        const arr = [];\n        if (tree.length == 1) {\n            return [\n                tree[0],\n                []\n            ];\n        }\n        if (typeof params == \"undefined\") throw new Error(\"Named query contains placeholders, but parameters object is undefined\");\n        const tokens = tree[1];\n        for(let i = 0; i < tokens.length; ++i){\n            arr.push(params[tokens[i]]);\n        }\n        return [\n            tree[0],\n            arr\n        ];\n    }\n    function noTailingSemicolon(s) {\n        if (s.slice(-1) == \":\") {\n            return s.slice(0, -1);\n        }\n        return s;\n    }\n    function join(tree) {\n        if (tree.length == 1) {\n            return tree;\n        }\n        let unnamed = noTailingSemicolon(tree[0][0]);\n        for(let i = 1; i < tree[0].length; ++i){\n            if (tree[0][i - 1].slice(-1) == \":\") {\n                unnamed += config.placeholder;\n            }\n            unnamed += config.placeholder;\n            unnamed += noTailingSemicolon(tree[0][i]);\n        }\n        const last = tree[0][tree[0].length - 1];\n        if (tree[0].length == tree[1].length) {\n            if (last.slice(-1) == \":\") {\n                unnamed += config.placeholder;\n            }\n            unnamed += config.placeholder;\n        }\n        return [\n            unnamed,\n            tree[1]\n        ];\n    }\n    function compile(query, paramsObj) {\n        let tree;\n        if (cache && (tree = cache.get(query))) {\n            return toArrayParams(tree, paramsObj);\n        }\n        tree = join(parse(query));\n        if (cache) {\n            cache.set(query, tree);\n        }\n        return toArrayParams(tree, paramsObj);\n    }\n    compile.parse = parse;\n    return compile;\n}\n// named :one :two to postgres-style numbered $1 $2 $3\nfunction toNumbered(q, params) {\n    const tree = parse(q);\n    const paramsArr = [];\n    if (tree.length == 1) {\n        return [\n            tree[0],\n            paramsArr\n        ];\n    }\n    const pIndexes = {};\n    let pLastIndex = 0;\n    let qs = \"\";\n    let varIndex;\n    const varNames = [];\n    for(let i = 0; i < tree[0].length; ++i){\n        varIndex = pIndexes[tree[1][i]];\n        if (!varIndex) {\n            varIndex = ++pLastIndex;\n            pIndexes[tree[1][i]] = varIndex;\n        }\n        if (tree[1][i]) {\n            varNames[varIndex - 1] = tree[1][i];\n            qs += tree[0][i] + \"$\" + varIndex;\n        } else {\n            qs += tree[0][i];\n        }\n    }\n    return [\n        qs,\n        varNames.map((n)=>params[n])\n    ];\n}\nmodule.exports = createCompiler;\nmodule.exports.toNumbered = toNumbered;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmFtZWQtcGxhY2Vob2xkZXJzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsd0lBQXdJO0FBQ3hJLHVFQUF1RTtBQUV2RSxNQUFNQSxXQUFXLGdEQUNqQkMsU0FBUyxJQUNUQyxTQUFTLElBQ1RDLFNBQVM7QUFFVCxTQUFTQyxNQUFNQyxLQUFLO0lBQ2xCLElBQUlDLE9BQU9OLFNBQVNPLElBQUksQ0FBQ0Y7SUFDekIsSUFBSUcsU0FBUztJQUNiLElBQUlDLFFBQVE7SUFDWixJQUFJQztJQUNKLE1BQU1DLFFBQVEsRUFBRTtJQUNoQixJQUFJQyxVQUFVO0lBQ2QsSUFBSUMsU0FBUztJQUNiLElBQUlDO0lBQ0osTUFBTUMsU0FBUyxFQUFFO0lBQ2pCLElBQUlDLE9BQU87SUFDWCxJQUFJQyxrQkFBa0I7SUFDdEIsSUFBSUM7SUFFSixJQUFJWixNQUFNO1FBQ1IsR0FBRztZQUNELElBQUtZLElBQUVWLFFBQU9FLE1BQUlKLEtBQUthLEtBQUssRUFBRUQsSUFBRVIsS0FBSyxFQUFFUSxFQUFHO2dCQUN4QyxJQUFJRSxNQUFNZixNQUFNZ0IsVUFBVSxDQUFDSDtnQkFDM0IsSUFBSUUsUUFBUWpCLFFBQ1pVLFNBQVMsQ0FBQ0E7cUJBQ0w7b0JBQ0gsSUFBSUEsUUFBUTt3QkFDVkEsU0FBUzt3QkFDVDtvQkFDRjtvQkFDQSxJQUFJRCxXQUFXUSxRQUFRTixNQUFNO3dCQUMzQixJQUFJVCxNQUFNZ0IsVUFBVSxDQUFDSCxJQUFJLE9BQU9KLE1BQU07NEJBQ3BDLDZCQUE2Qjs0QkFDN0IsRUFBRUk7NEJBQ0Y7d0JBQ0Y7d0JBQ0FOLFVBQVU7b0JBQ1osT0FBTyxJQUFJUSxRQUFRbkIsVUFBVW1CLFFBQVFsQixRQUFRO3dCQUMzQ1UsVUFBVTt3QkFDVkUsT0FBT007b0JBQ1Q7Z0JBQ0Y7WUFDRjtZQUNBLElBQUksQ0FBQ1IsU0FBUztnQkFDWkQsTUFBTVcsSUFBSSxDQUFDakIsTUFBTWtCLFNBQVMsQ0FBQ2QsT0FBT0M7Z0JB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QUMvQixJQUFJLENBQUNtQyxVQUFVO1lBQ2JBLFdBQVcsRUFBRUY7WUFDYkQsUUFBUSxDQUFDakIsSUFBSSxDQUFDLEVBQUUsQ0FBQ2YsRUFBRSxDQUFDLEdBQUdtQztRQUN6QjtRQUNBLElBQUlwQixJQUFJLENBQUMsRUFBRSxDQUFDZixFQUFFLEVBQUU7WUFDZG9DLFFBQVEsQ0FBQ0QsV0FBVyxFQUFFLEdBQUdwQixJQUFJLENBQUMsRUFBRSxDQUFDZixFQUFFO1lBQ25Da0MsTUFBTW5CLElBQUksQ0FBQyxFQUFFLENBQUNmLEVBQUUsR0FBRyxNQUFNbUM7UUFDM0IsT0FBTztZQUNMRCxNQUFNbkIsSUFBSSxDQUFDLEVBQUUsQ0FBQ2YsRUFBRTtRQUNsQjtJQUNGO0lBQ0EsT0FBTztRQUFDa0M7UUFBSUUsU0FBU0MsR0FBRyxDQUFDQyxDQUFBQSxJQUFLdEIsTUFBTSxDQUFDc0IsRUFBRTtLQUFFO0FBQzNDO0FBRUFDLE9BQU9DLE9BQU8sR0FBR2pDO0FBQ2pCZ0MseUJBQXlCLEdBQUdWIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ydHVndWVzZS1xdW90ZS1jYXJkLy4vbm9kZV9tb2R1bGVzL25hbWVkLXBsYWNlaG9sZGVycy9pbmRleC5qcz8yYmVhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLy8gYmFzZWQgb24gY29kZSBmcm9tIEJyaWFuIFdoaXRlIEBtc2NkZXggbWFyaWFzcWwgbGlicmFyeSAtIGh0dHBzOi8vZ2l0aHViLmNvbS9tc2NkZXgvbm9kZS1tYXJpYXNxbC9ibG9iL21hc3Rlci9saWIvQ2xpZW50LmpzI0wyNzItTDMzMlxuLy8gTGljZW5zZTogaHR0cHM6Ly9naXRodWIuY29tL21zY2RleC9ub2RlLW1hcmlhc3FsL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcblxuY29uc3QgUkVfUEFSQU0gPSAvKD86XFw/KXwoPzo6KFxcZCt8KD86W2EtekEtWl1bYS16QS1aMC05X10qKSkpL2csXG5EUVVPVEUgPSAzNCxcblNRVU9URSA9IDM5LFxuQlNMQVNIID0gOTI7XG5cbmZ1bmN0aW9uIHBhcnNlKHF1ZXJ5KSB7XG4gIGxldCBwcG9zID0gUkVfUEFSQU0uZXhlYyhxdWVyeSk7XG4gIGxldCBjdXJwb3MgPSAwO1xuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgZW5kO1xuICBjb25zdCBwYXJ0cyA9IFtdO1xuICBsZXQgaW5RdW90ZSA9IGZhbHNlO1xuICBsZXQgZXNjYXBlID0gZmFsc2U7XG4gIGxldCBxY2hyO1xuICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgbGV0IHFjbnQgPSAwO1xuICBsZXQgbGFzdFRva2VuRW5kUG9zID0gMDtcbiAgbGV0IGk7XG5cbiAgaWYgKHBwb3MpIHtcbiAgICBkbyB7XG4gICAgICBmb3IgKGk9Y3VycG9zLGVuZD1wcG9zLmluZGV4OyBpPGVuZDsgKytpKSB7XG4gICAgICAgIGxldCBjaHIgPSBxdWVyeS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY2hyID09PSBCU0xBU0gpXG4gICAgICAgIGVzY2FwZSA9ICFlc2NhcGU7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChlc2NhcGUpIHtcbiAgICAgICAgICAgIGVzY2FwZSA9IGZhbHNlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpblF1b3RlICYmIGNociA9PT0gcWNocikge1xuICAgICAgICAgICAgaWYgKHF1ZXJ5LmNoYXJDb2RlQXQoaSArIDEpID09PSBxY2hyKSB7XG4gICAgICAgICAgICAgIC8vIHF1b3RlIGVzY2FwZWQgdmlhIFwiXCIgb3IgJydcbiAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluUXVvdGUgPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNociA9PT0gRFFVT1RFIHx8IGNociA9PT0gU1FVT1RFKSB7XG4gICAgICAgICAgICBpblF1b3RlID0gdHJ1ZTtcbiAgICAgICAgICAgIHFjaHIgPSBjaHI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWluUXVvdGUpIHtcbiAgICAgICAgcGFydHMucHVzaChxdWVyeS5zdWJzdHJpbmcoc3RhcnQsIGVuZCkpO1xuICAgICAgICB0b2tlbnMucHVzaChwcG9zWzBdLmxlbmd0aCA9PT0gMSA/IHFjbnQrKyA6IHBwb3NbMV0pO1xuICAgICAgICBzdGFydCA9IGVuZCArIHBwb3NbMF0ubGVuZ3RoO1xuICAgICAgICBsYXN0VG9rZW5FbmRQb3MgPSBzdGFydDtcbiAgICAgIH1cbiAgICAgIGN1cnBvcyA9IGVuZCArIHBwb3NbMF0ubGVuZ3RoO1xuICAgIH0gd2hpbGUgKHBwb3MgPSBSRV9QQVJBTS5leGVjKHF1ZXJ5KSk7XG5cbiAgICBpZiAodG9rZW5zLmxlbmd0aCkge1xuICAgICAgaWYgKGN1cnBvcyA8IHF1ZXJ5Lmxlbmd0aCkge1xuICAgICAgICBwYXJ0cy5wdXNoKHF1ZXJ5LnN1YnN0cmluZyhsYXN0VG9rZW5FbmRQb3MpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbcGFydHMsIHRva2Vuc107XG4gICAgfVxuICB9XG4gIHJldHVybiBbcXVlcnldO1xufTtcblxuZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXIoY29uZmlnKSB7XG4gIGlmICghY29uZmlnKVxuICBjb25maWcgPSB7fTtcbiAgaWYgKCFjb25maWcucGxhY2Vob2xkZXIpIHtcbiAgICBjb25maWcucGxhY2Vob2xkZXIgPSAnPyc7XG4gIH1cbiAgbGV0IG5jYWNoZSA9IDEwMDtcbiAgbGV0IGNhY2hlO1xuICBpZiAodHlwZW9mIGNvbmZpZy5jYWNoZSA9PT0gJ251bWJlcicpIHtcbiAgICBuY2FjaGUgPSBjb25maWcuY2FjaGU7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb25maWcuY2FjaGUgPT09ICdvYmplY3QnKSB7XG4gICAgY2FjaGUgPSBjb25maWcuY2FjaGU7XG4gIH1cbiAgaWYgKGNvbmZpZy5jYWNoZSAhPT0gZmFsc2UgJiYgIWNhY2hlKSB7XG4gICAgY2FjaGUgPSBuZXcgKHJlcXVpcmUoJ2xydS1jYWNoZScpKSh7IG1heDogbmNhY2hlIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9BcnJheVBhcmFtcyh0cmVlLCBwYXJhbXMpIHtcbiAgICBjb25zdCBhcnIgPSBbXTtcbiAgICBpZiAodHJlZS5sZW5ndGggPT0gMSkge1xuICAgICAgcmV0dXJuIFt0cmVlWzBdLCBbXV07XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBwYXJhbXMgPT0gJ3VuZGVmaW5lZCcpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05hbWVkIHF1ZXJ5IGNvbnRhaW5zIHBsYWNlaG9sZGVycywgYnV0IHBhcmFtZXRlcnMgb2JqZWN0IGlzIHVuZGVmaW5lZCcpO1xuXG4gICAgY29uc3QgdG9rZW5zID0gdHJlZVsxXTtcbiAgICBmb3IgKGxldCBpPTA7IGkgPCB0b2tlbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGFyci5wdXNoKHBhcmFtc1t0b2tlbnNbaV1dKTtcbiAgICB9XG4gICAgcmV0dXJuIFt0cmVlWzBdLCBhcnJdO1xuICB9XG5cbiAgZnVuY3Rpb24gbm9UYWlsaW5nU2VtaWNvbG9uKHMpIHtcbiAgICBpZiAocy5zbGljZSgtMSkgPT0gJzonKSB7XG4gICAgICByZXR1cm4gcy5zbGljZSgwLCAtMSk7XG4gICAgfVxuICAgIHJldHVybiBzO1xuICB9XG5cbiAgZnVuY3Rpb24gam9pbih0cmVlKSB7XG4gICAgaWYgKHRyZWUubGVuZ3RoID09IDEpIHtcbiAgICAgIHJldHVybiB0cmVlO1xuICAgIH1cblxuICAgIGxldCB1bm5hbWVkID0gbm9UYWlsaW5nU2VtaWNvbG9uKHRyZWVbMF1bMF0pO1xuICAgIGZvciAobGV0IGk9MTsgaSA8IHRyZWVbMF0ubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmICh0cmVlWzBdW2ktMV0uc2xpY2UoLTEpID09ICc6Jykge1xuICAgICAgICB1bm5hbWVkICs9IGNvbmZpZy5wbGFjZWhvbGRlcjtcbiAgICAgIH1cbiAgICAgIHVubmFtZWQgKz0gY29uZmlnLnBsYWNlaG9sZGVyO1xuICAgICAgdW5uYW1lZCArPSBub1RhaWxpbmdTZW1pY29sb24odHJlZVswXVtpXSk7XG4gICAgfVxuXG4gICAgY29uc3QgbGFzdCA9IHRyZWVbMF1bdHJlZVswXS5sZW5ndGggLTFdO1xuICAgIGlmICh0cmVlWzBdLmxlbmd0aCA9PSB0cmVlWzFdLmxlbmd0aCkge1xuICAgICAgaWYgKGxhc3Quc2xpY2UoLTEpID09ICc6Jykge1xuICAgICAgICB1bm5hbWVkICs9IGNvbmZpZy5wbGFjZWhvbGRlcjtcbiAgICAgIH1cbiAgICAgIHVubmFtZWQgKz0gY29uZmlnLnBsYWNlaG9sZGVyO1xuICAgIH1cbiAgICByZXR1cm4gW3VubmFtZWQsIHRyZWVbMV1dO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcGlsZShxdWVyeSwgcGFyYW1zT2JqKSB7XG4gICAgbGV0IHRyZWU7XG4gICAgaWYgKGNhY2hlICYmICh0cmVlID0gY2FjaGUuZ2V0KHF1ZXJ5KSkpIHtcbiAgICAgIHJldHVybiB0b0FycmF5UGFyYW1zKHRyZWUsIHBhcmFtc09iailcbiAgICB9XG4gICAgdHJlZSA9IGpvaW4ocGFyc2UocXVlcnkpKTtcbiAgICBpZihjYWNoZSkge1xuICAgICAgY2FjaGUuc2V0KHF1ZXJ5LCB0cmVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvQXJyYXlQYXJhbXModHJlZSwgcGFyYW1zT2JqKTtcbiAgfVxuXG4gIGNvbXBpbGUucGFyc2UgPSBwYXJzZTtcbiAgcmV0dXJuIGNvbXBpbGU7XG59XG5cbi8vIG5hbWVkIDpvbmUgOnR3byB0byBwb3N0Z3Jlcy1zdHlsZSBudW1iZXJlZCAkMSAkMiAkM1xuZnVuY3Rpb24gdG9OdW1iZXJlZChxLCBwYXJhbXMpIHtcbiAgY29uc3QgdHJlZSA9IHBhcnNlKHEpO1xuICBjb25zdCBwYXJhbXNBcnIgPSBbXTtcbiAgaWYgKHRyZWUubGVuZ3RoID09IDEpIHtcbiAgICByZXR1cm4gW3RyZWVbMF0sIHBhcmFtc0Fycl07XG4gIH1cblxuICBjb25zdCBwSW5kZXhlcyA9IHt9O1xuICBsZXQgcExhc3RJbmRleCA9IDA7XG4gIGxldCBxcyA9ICcnO1xuICBsZXQgdmFySW5kZXg7XG4gIGNvbnN0IHZhck5hbWVzID0gW107XG4gIGZvciAobGV0IGk9MDsgaSA8IHRyZWVbMF0ubGVuZ3RoOyArK2kpIHtcbiAgICB2YXJJbmRleCA9IHBJbmRleGVzW3RyZWVbMV1baV1dO1xuICAgIGlmICghdmFySW5kZXgpIHtcbiAgICAgIHZhckluZGV4ID0gKytwTGFzdEluZGV4O1xuICAgICAgcEluZGV4ZXNbdHJlZVsxXVtpXV0gPSB2YXJJbmRleDtcbiAgICB9XG4gICAgaWYgKHRyZWVbMV1baV0pIHtcbiAgICAgIHZhck5hbWVzW3ZhckluZGV4IC0gMV0gPSB0cmVlWzFdW2ldO1xuICAgICAgcXMgKz0gdHJlZVswXVtpXSArICckJyArIHZhckluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICBxcyArPSB0cmVlWzBdW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW3FzLCB2YXJOYW1lcy5tYXAobiA9PiBwYXJhbXNbbl0pXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVDb21waWxlcjtcbm1vZHVsZS5leHBvcnRzLnRvTnVtYmVyZWQgPSB0b051bWJlcmVkO1xuIl0sIm5hbWVzIjpbIlJFX1BBUkFNIiwiRFFVT1RFIiwiU1FVT1RFIiwiQlNMQVNIIiwicGFyc2UiLCJxdWVyeSIsInBwb3MiLCJleGVjIiwiY3VycG9zIiwic3RhcnQiLCJlbmQiLCJwYXJ0cyIsImluUXVvdGUiLCJlc2NhcGUiLCJxY2hyIiwidG9rZW5zIiwicWNudCIsImxhc3RUb2tlbkVuZFBvcyIsImkiLCJpbmRleCIsImNociIsImNoYXJDb2RlQXQiLCJwdXNoIiwic3Vic3RyaW5nIiwibGVuZ3RoIiwiY3JlYXRlQ29tcGlsZXIiLCJjb25maWciLCJwbGFjZWhvbGRlciIsIm5jYWNoZSIsImNhY2hlIiwicmVxdWlyZSIsIm1heCIsInRvQXJyYXlQYXJhbXMiLCJ0cmVlIiwicGFyYW1zIiwiYXJyIiwiRXJyb3IiLCJub1RhaWxpbmdTZW1pY29sb24iLCJzIiwic2xpY2UiLCJqb2luIiwidW5uYW1lZCIsImxhc3QiLCJjb21waWxlIiwicGFyYW1zT2JqIiwiZ2V0Iiwic2V0IiwidG9OdW1iZXJlZCIsInEiLCJwYXJhbXNBcnIiLCJwSW5kZXhlcyIsInBMYXN0SW5kZXgiLCJxcyIsInZhckluZGV4IiwidmFyTmFtZXMiLCJtYXAiLCJuIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/named-placeholders/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/named-placeholders/node_modules/lru-cache/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/named-placeholders/node_modules/lru-cache/index.js ***!
  \*************************************************************************/
/***/ ((module) => {

eval("const perf = typeof performance === \"object\" && performance && typeof performance.now === \"function\" ? performance : Date;\nconst hasAbortController = typeof AbortController === \"function\";\n// minimal backwards-compatibility polyfill\n// this doesn't have nearly all the checks and whatnot that\n// actual AbortController/Signal has, but it's enough for\n// our purposes, and if used properly, behaves the same.\nconst AC = hasAbortController ? AbortController : class AbortController1 {\n    constructor(){\n        this.signal = new AS();\n    }\n    abort(reason = new Error(\"This operation was aborted\")) {\n        this.signal.reason = this.signal.reason || reason;\n        this.signal.aborted = true;\n        this.signal.dispatchEvent({\n            type: \"abort\",\n            target: this.signal\n        });\n    }\n};\nconst hasAbortSignal = typeof AbortSignal === \"function\";\n// Some polyfills put this on the AC class, not global\nconst hasACAbortSignal = typeof AC.AbortSignal === \"function\";\nconst AS = hasAbortSignal ? AbortSignal : hasACAbortSignal ? AC.AbortController : class AbortSignal1 {\n    constructor(){\n        this.reason = undefined;\n        this.aborted = false;\n        this._listeners = [];\n    }\n    dispatchEvent(e) {\n        if (e.type === \"abort\") {\n            this.aborted = true;\n            this.onabort(e);\n            this._listeners.forEach((f)=>f(e), this);\n        }\n    }\n    onabort() {}\n    addEventListener(ev, fn) {\n        if (ev === \"abort\") {\n            this._listeners.push(fn);\n        }\n    }\n    removeEventListener(ev, fn) {\n        if (ev === \"abort\") {\n            this._listeners = this._listeners.filter((f)=>f !== fn);\n        }\n    }\n};\nconst warned = new Set();\nconst deprecatedOption = (opt, instead)=>{\n    const code = `LRU_CACHE_OPTION_${opt}`;\n    if (shouldWarn(code)) {\n        warn(code, `${opt} option`, `options.${instead}`, LRUCache);\n    }\n};\nconst deprecatedMethod = (method, instead)=>{\n    const code = `LRU_CACHE_METHOD_${method}`;\n    if (shouldWarn(code)) {\n        const { prototype } = LRUCache;\n        const { get } = Object.getOwnPropertyDescriptor(prototype, method);\n        warn(code, `${method} method`, `cache.${instead}()`, get);\n    }\n};\nconst deprecatedProperty = (field, instead)=>{\n    const code = `LRU_CACHE_PROPERTY_${field}`;\n    if (shouldWarn(code)) {\n        const { prototype } = LRUCache;\n        const { get } = Object.getOwnPropertyDescriptor(prototype, field);\n        warn(code, `${field} property`, `cache.${instead}`, get);\n    }\n};\nconst emitWarning = (...a)=>{\n    typeof process === \"object\" && process && typeof process.emitWarning === \"function\" ? process.emitWarning(...a) : console.error(...a);\n};\nconst shouldWarn = (code)=>!warned.has(code);\nconst warn = (code, what, instead, fn)=>{\n    warned.add(code);\n    const msg = `The ${what} is deprecated. Please use ${instead} instead.`;\n    emitWarning(msg, \"DeprecationWarning\", code, fn);\n};\nconst isPosInt = (n)=>n && n === Math.floor(n) && n > 0 && isFinite(n);\n/* istanbul ignore next - This is a little bit ridiculous, tbh.\n * The maximum array length is 2^32-1 or thereabouts on most JS impls.\n * And well before that point, you're caching the entire world, I mean,\n * that's ~32GB of just integers for the next/prev links, plus whatever\n * else to hold that many keys and values.  Just filling the memory with\n * zeroes at init time is brutal when you get that big.\n * But why not be complete?\n * Maybe in the future, these limits will have expanded. */ const getUintArray = (max)=>!isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;\nclass ZeroArray extends Array {\n    constructor(size){\n        super(size);\n        this.fill(0);\n    }\n}\nclass Stack {\n    constructor(max){\n        if (max === 0) {\n            return [];\n        }\n        const UintArray = getUintArray(max);\n        this.heap = new UintArray(max);\n        this.length = 0;\n    }\n    push(n) {\n        this.heap[this.length++] = n;\n    }\n    pop() {\n        return this.heap[--this.length];\n    }\n}\nclass LRUCache {\n    constructor(options = {}){\n        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, fetchContext, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;\n        // deprecated options, don't trigger a warning for getting them if\n        // the thing being passed in is another LRUCache we're copying.\n        const { length, maxAge, stale } = options instanceof LRUCache ? {} : options;\n        if (max !== 0 && !isPosInt(max)) {\n            throw new TypeError(\"max option must be a nonnegative integer\");\n        }\n        const UintArray = max ? getUintArray(max) : Array;\n        if (!UintArray) {\n            throw new Error(\"invalid max value: \" + max);\n        }\n        this.max = max;\n        this.maxSize = maxSize;\n        this.maxEntrySize = maxEntrySize || this.maxSize;\n        this.sizeCalculation = sizeCalculation || length;\n        if (this.sizeCalculation) {\n            if (!this.maxSize && !this.maxEntrySize) {\n                throw new TypeError(\"cannot set sizeCalculation without setting maxSize or maxEntrySize\");\n            }\n            if (typeof this.sizeCalculation !== \"function\") {\n                throw new TypeError(\"sizeCalculation set to non-function\");\n            }\n        }\n        this.fetchMethod = fetchMethod || null;\n        if (this.fetchMethod && typeof this.fetchMethod !== \"function\") {\n            throw new TypeError(\"fetchMethod must be a function if specified\");\n        }\n        this.fetchContext = fetchContext;\n        if (!this.fetchMethod && fetchContext !== undefined) {\n            throw new TypeError(\"cannot set fetchContext without fetchMethod\");\n        }\n        this.keyMap = new Map();\n        this.keyList = new Array(max).fill(null);\n        this.valList = new Array(max).fill(null);\n        this.next = new UintArray(max);\n        this.prev = new UintArray(max);\n        this.head = 0;\n        this.tail = 0;\n        this.free = new Stack(max);\n        this.initialFill = 1;\n        this.size = 0;\n        if (typeof dispose === \"function\") {\n            this.dispose = dispose;\n        }\n        if (typeof disposeAfter === \"function\") {\n            this.disposeAfter = disposeAfter;\n            this.disposed = [];\n        } else {\n            this.disposeAfter = null;\n            this.disposed = null;\n        }\n        this.noDisposeOnSet = !!noDisposeOnSet;\n        this.noUpdateTTL = !!noUpdateTTL;\n        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;\n        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;\n        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;\n        this.ignoreFetchAbort = !!ignoreFetchAbort;\n        // NB: maxEntrySize is set to maxSize if it's set\n        if (this.maxEntrySize !== 0) {\n            if (this.maxSize !== 0) {\n                if (!isPosInt(this.maxSize)) {\n                    throw new TypeError(\"maxSize must be a positive integer if specified\");\n                }\n            }\n            if (!isPosInt(this.maxEntrySize)) {\n                throw new TypeError(\"maxEntrySize must be a positive integer if specified\");\n            }\n            this.initializeSizeTracking();\n        }\n        this.allowStale = !!allowStale || !!stale;\n        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;\n        this.updateAgeOnGet = !!updateAgeOnGet;\n        this.updateAgeOnHas = !!updateAgeOnHas;\n        this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;\n        this.ttlAutopurge = !!ttlAutopurge;\n        this.ttl = ttl || maxAge || 0;\n        if (this.ttl) {\n            if (!isPosInt(this.ttl)) {\n                throw new TypeError(\"ttl must be a positive integer if specified\");\n            }\n            this.initializeTTLTracking();\n        }\n        // do not allow completely unbounded caches\n        if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) {\n            throw new TypeError(\"At least one of max, maxSize, or ttl is required\");\n        }\n        if (!this.ttlAutopurge && !this.max && !this.maxSize) {\n            const code = \"LRU_CACHE_UNBOUNDED\";\n            if (shouldWarn(code)) {\n                warned.add(code);\n                const msg = \"TTL caching without ttlAutopurge, max, or maxSize can \" + \"result in unbounded memory consumption.\";\n                emitWarning(msg, \"UnboundedCacheWarning\", code, LRUCache);\n            }\n        }\n        if (stale) {\n            deprecatedOption(\"stale\", \"allowStale\");\n        }\n        if (maxAge) {\n            deprecatedOption(\"maxAge\", \"ttl\");\n        }\n        if (length) {\n            deprecatedOption(\"length\", \"sizeCalculation\");\n        }\n    }\n    getRemainingTTL(key) {\n        return this.has(key, {\n            updateAgeOnHas: false\n        }) ? Infinity : 0;\n    }\n    initializeTTLTracking() {\n        this.ttls = new ZeroArray(this.max);\n        this.starts = new ZeroArray(this.max);\n        this.setItemTTL = (index, ttl, start = perf.now())=>{\n            this.starts[index] = ttl !== 0 ? start : 0;\n            this.ttls[index] = ttl;\n            if (ttl !== 0 && this.ttlAutopurge) {\n                const t = setTimeout(()=>{\n                    if (this.isStale(index)) {\n                        this.delete(this.keyList[index]);\n                    }\n                }, ttl + 1);\n                /* istanbul ignore else - unref() not supported on all platforms */ if (t.unref) {\n                    t.unref();\n                }\n            }\n        };\n        this.updateItemAge = (index)=>{\n            this.starts[index] = this.ttls[index] !== 0 ? perf.now() : 0;\n        };\n        this.statusTTL = (status, index)=>{\n            if (status) {\n                status.ttl = this.ttls[index];\n                status.start = this.starts[index];\n                status.now = cachedNow || getNow();\n                status.remainingTTL = status.now + status.ttl - status.start;\n            }\n        };\n        // debounce calls to perf.now() to 1s so we're not hitting\n        // that costly call repeatedly.\n        let cachedNow = 0;\n        const getNow = ()=>{\n            const n = perf.now();\n            if (this.ttlResolution > 0) {\n                cachedNow = n;\n                const t = setTimeout(()=>cachedNow = 0, this.ttlResolution);\n                /* istanbul ignore else - not available on all platforms */ if (t.unref) {\n                    t.unref();\n                }\n            }\n            return n;\n        };\n        this.getRemainingTTL = (key)=>{\n            const index = this.keyMap.get(key);\n            if (index === undefined) {\n                return 0;\n            }\n            return this.ttls[index] === 0 || this.starts[index] === 0 ? Infinity : this.starts[index] + this.ttls[index] - (cachedNow || getNow());\n        };\n        this.isStale = (index)=>{\n            return this.ttls[index] !== 0 && this.starts[index] !== 0 && (cachedNow || getNow()) - this.starts[index] > this.ttls[index];\n        };\n    }\n    updateItemAge(_index) {}\n    statusTTL(_status, _index) {}\n    setItemTTL(_index, _ttl, _start) {}\n    isStale(_index) {\n        return false;\n    }\n    initializeSizeTracking() {\n        this.calculatedSize = 0;\n        this.sizes = new ZeroArray(this.max);\n        this.removeItemSize = (index)=>{\n            this.calculatedSize -= this.sizes[index];\n            this.sizes[index] = 0;\n        };\n        this.requireSize = (k, v, size, sizeCalculation)=>{\n            // provisionally accept background fetches.\n            // actual value size will be checked when they return.\n            if (this.isBackgroundFetch(v)) {\n                return 0;\n            }\n            if (!isPosInt(size)) {\n                if (sizeCalculation) {\n                    if (typeof sizeCalculation !== \"function\") {\n                        throw new TypeError(\"sizeCalculation must be a function\");\n                    }\n                    size = sizeCalculation(v, k);\n                    if (!isPosInt(size)) {\n                        throw new TypeError(\"sizeCalculation return invalid (expect positive integer)\");\n                    }\n                } else {\n                    throw new TypeError(\"invalid size value (must be positive integer). \" + \"When maxSize or maxEntrySize is used, sizeCalculation or size \" + \"must be set.\");\n                }\n            }\n            return size;\n        };\n        this.addItemSize = (index, size, status)=>{\n            this.sizes[index] = size;\n            if (this.maxSize) {\n                const maxSize = this.maxSize - this.sizes[index];\n                while(this.calculatedSize > maxSize){\n                    this.evict(true);\n                }\n            }\n            this.calculatedSize += this.sizes[index];\n            if (status) {\n                status.entrySize = size;\n                status.totalCalculatedSize = this.calculatedSize;\n            }\n        };\n    }\n    removeItemSize(_index) {}\n    addItemSize(_index, _size) {}\n    requireSize(_k, _v, size, sizeCalculation) {\n        if (size || sizeCalculation) {\n            throw new TypeError(\"cannot set size without setting maxSize or maxEntrySize on cache\");\n        }\n    }\n    *indexes({ allowStale = this.allowStale } = {}) {\n        if (this.size) {\n            for(let i = this.tail; true;){\n                if (!this.isValidIndex(i)) {\n                    break;\n                }\n                if (allowStale || !this.isStale(i)) {\n                    yield i;\n                }\n                if (i === this.head) {\n                    break;\n                } else {\n                    i = this.prev[i];\n                }\n            }\n        }\n    }\n    *rindexes({ allowStale = this.allowStale } = {}) {\n        if (this.size) {\n            for(let i = this.head; true;){\n                if (!this.isValidIndex(i)) {\n                    break;\n                }\n                if (allowStale || !this.isStale(i)) {\n                    yield i;\n                }\n                if (i === this.tail) {\n                    break;\n                } else {\n                    i = this.next[i];\n                }\n            }\n        }\n    }\n    isValidIndex(index) {\n        return index !== undefined && this.keyMap.get(this.keyList[index]) === index;\n    }\n    *entries() {\n        for (const i of this.indexes()){\n            if (this.valList[i] !== undefined && this.keyList[i] !== undefined && !this.isBackgroundFetch(this.valList[i])) {\n                yield [\n                    this.keyList[i],\n                    this.valList[i]\n                ];\n            }\n        }\n    }\n    *rentries() {\n        for (const i of this.rindexes()){\n            if (this.valList[i] !== undefined && this.keyList[i] !== undefined && !this.isBackgroundFetch(this.valList[i])) {\n                yield [\n                    this.keyList[i],\n                    this.valList[i]\n                ];\n            }\n        }\n    }\n    *keys() {\n        for (const i of this.indexes()){\n            if (this.keyList[i] !== undefined && !this.isBackgroundFetch(this.valList[i])) {\n                yield this.keyList[i];\n            }\n        }\n    }\n    *rkeys() {\n        for (const i of this.rindexes()){\n            if (this.keyList[i] !== undefined && !this.isBackgroundFetch(this.valList[i])) {\n                yield this.keyList[i];\n            }\n        }\n    }\n    *values() {\n        for (const i of this.indexes()){\n            if (this.valList[i] !== undefined && !this.isBackgroundFetch(this.valList[i])) {\n                yield this.valList[i];\n            }\n        }\n    }\n    *rvalues() {\n        for (const i of this.rindexes()){\n            if (this.valList[i] !== undefined && !this.isBackgroundFetch(this.valList[i])) {\n                yield this.valList[i];\n            }\n        }\n    }\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n    find(fn, getOptions) {\n        for (const i of this.indexes()){\n            const v = this.valList[i];\n            const value = this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n            if (value === undefined) continue;\n            if (fn(value, this.keyList[i], this)) {\n                return this.get(this.keyList[i], getOptions);\n            }\n        }\n    }\n    forEach(fn, thisp = this) {\n        for (const i of this.indexes()){\n            const v = this.valList[i];\n            const value = this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n            if (value === undefined) continue;\n            fn.call(thisp, value, this.keyList[i], this);\n        }\n    }\n    rforEach(fn, thisp = this) {\n        for (const i of this.rindexes()){\n            const v = this.valList[i];\n            const value = this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n            if (value === undefined) continue;\n            fn.call(thisp, value, this.keyList[i], this);\n        }\n    }\n    get prune() {\n        deprecatedMethod(\"prune\", \"purgeStale\");\n        return this.purgeStale;\n    }\n    purgeStale() {\n        let deleted = false;\n        for (const i of this.rindexes({\n            allowStale: true\n        })){\n            if (this.isStale(i)) {\n                this.delete(this.keyList[i]);\n                deleted = true;\n            }\n        }\n        return deleted;\n    }\n    dump() {\n        const arr = [];\n        for (const i of this.indexes({\n            allowStale: true\n        })){\n            const key = this.keyList[i];\n            const v = this.valList[i];\n            const value = this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n            if (value === undefined) continue;\n            const entry = {\n                value\n            };\n            if (this.ttls) {\n                entry.ttl = this.ttls[i];\n                // always dump the start relative to a portable timestamp\n                // it's ok for this to be a bit slow, it's a rare operation.\n                const age = perf.now() - this.starts[i];\n                entry.start = Math.floor(Date.now() - age);\n            }\n            if (this.sizes) {\n                entry.size = this.sizes[i];\n            }\n            arr.unshift([\n                key,\n                entry\n            ]);\n        }\n        return arr;\n    }\n    load(arr) {\n        this.clear();\n        for (const [key, entry] of arr){\n            if (entry.start) {\n                // entry.start is a portable timestamp, but we may be using\n                // node's performance.now(), so calculate the offset.\n                // it's ok for this to be a bit slow, it's a rare operation.\n                const age = Date.now() - entry.start;\n                entry.start = perf.now() - age;\n            }\n            this.set(key, entry.value, entry);\n        }\n    }\n    dispose(_v, _k, _reason) {}\n    set(k, v, { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, status } = {}) {\n        size = this.requireSize(k, v, size, sizeCalculation);\n        // if the item doesn't fit, don't do anything\n        // NB: maxEntrySize set to maxSize by default\n        if (this.maxEntrySize && size > this.maxEntrySize) {\n            if (status) {\n                status.set = \"miss\";\n                status.maxEntrySizeExceeded = true;\n            }\n            // have to delete, in case a background fetch is there already.\n            // in non-async cases, this is a no-op\n            this.delete(k);\n            return this;\n        }\n        let index = this.size === 0 ? undefined : this.keyMap.get(k);\n        if (index === undefined) {\n            // addition\n            index = this.newIndex();\n            this.keyList[index] = k;\n            this.valList[index] = v;\n            this.keyMap.set(k, index);\n            this.next[this.tail] = index;\n            this.prev[index] = this.tail;\n            this.tail = index;\n            this.size++;\n            this.addItemSize(index, size, status);\n            if (status) {\n                status.set = \"add\";\n            }\n            noUpdateTTL = false;\n        } else {\n            // update\n            this.moveToTail(index);\n            const oldVal = this.valList[index];\n            if (v !== oldVal) {\n                if (this.isBackgroundFetch(oldVal)) {\n                    oldVal.__abortController.abort(new Error(\"replaced\"));\n                } else {\n                    if (!noDisposeOnSet) {\n                        this.dispose(oldVal, k, \"set\");\n                        if (this.disposeAfter) {\n                            this.disposed.push([\n                                oldVal,\n                                k,\n                                \"set\"\n                            ]);\n                        }\n                    }\n                }\n                this.removeItemSize(index);\n                this.valList[index] = v;\n                this.addItemSize(index, size, status);\n                if (status) {\n                    status.set = \"replace\";\n                    const oldValue = oldVal && this.isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;\n                    if (oldValue !== undefined) status.oldValue = oldValue;\n                }\n            } else if (status) {\n                status.set = \"update\";\n            }\n        }\n        if (ttl !== 0 && this.ttl === 0 && !this.ttls) {\n            this.initializeTTLTracking();\n        }\n        if (!noUpdateTTL) {\n            this.setItemTTL(index, ttl, start);\n        }\n        this.statusTTL(status, index);\n        if (this.disposeAfter) {\n            while(this.disposed.length){\n                this.disposeAfter(...this.disposed.shift());\n            }\n        }\n        return this;\n    }\n    newIndex() {\n        if (this.size === 0) {\n            return this.tail;\n        }\n        if (this.size === this.max && this.max !== 0) {\n            return this.evict(false);\n        }\n        if (this.free.length !== 0) {\n            return this.free.pop();\n        }\n        // initial fill, just keep writing down the list\n        return this.initialFill++;\n    }\n    pop() {\n        if (this.size) {\n            const val = this.valList[this.head];\n            this.evict(true);\n            return val;\n        }\n    }\n    evict(free) {\n        const head = this.head;\n        const k = this.keyList[head];\n        const v = this.valList[head];\n        if (this.isBackgroundFetch(v)) {\n            v.__abortController.abort(new Error(\"evicted\"));\n        } else {\n            this.dispose(v, k, \"evict\");\n            if (this.disposeAfter) {\n                this.disposed.push([\n                    v,\n                    k,\n                    \"evict\"\n                ]);\n            }\n        }\n        this.removeItemSize(head);\n        // if we aren't about to use the index, then null these out\n        if (free) {\n            this.keyList[head] = null;\n            this.valList[head] = null;\n            this.free.push(head);\n        }\n        this.head = this.next[head];\n        this.keyMap.delete(k);\n        this.size--;\n        return head;\n    }\n    has(k, { updateAgeOnHas = this.updateAgeOnHas, status } = {}) {\n        const index = this.keyMap.get(k);\n        if (index !== undefined) {\n            if (!this.isStale(index)) {\n                if (updateAgeOnHas) {\n                    this.updateItemAge(index);\n                }\n                if (status) status.has = \"hit\";\n                this.statusTTL(status, index);\n                return true;\n            } else if (status) {\n                status.has = \"stale\";\n                this.statusTTL(status, index);\n            }\n        } else if (status) {\n            status.has = \"miss\";\n        }\n        return false;\n    }\n    // like get(), but without any LRU updating or TTL expiration\n    peek(k, { allowStale = this.allowStale } = {}) {\n        const index = this.keyMap.get(k);\n        if (index !== undefined && (allowStale || !this.isStale(index))) {\n            const v = this.valList[index];\n            // either stale and allowed, or forcing a refresh of non-stale value\n            return this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n        }\n    }\n    backgroundFetch(k, index, options, context) {\n        const v = index === undefined ? undefined : this.valList[index];\n        if (this.isBackgroundFetch(v)) {\n            return v;\n        }\n        const ac = new AC();\n        if (options.signal) {\n            options.signal.addEventListener(\"abort\", ()=>ac.abort(options.signal.reason));\n        }\n        const fetchOpts = {\n            signal: ac.signal,\n            options,\n            context\n        };\n        const cb = (v, updateCache = false)=>{\n            const { aborted } = ac.signal;\n            const ignoreAbort = options.ignoreFetchAbort && v !== undefined;\n            if (options.status) {\n                if (aborted && !updateCache) {\n                    options.status.fetchAborted = true;\n                    options.status.fetchError = ac.signal.reason;\n                    if (ignoreAbort) options.status.fetchAbortIgnored = true;\n                } else {\n                    options.status.fetchResolved = true;\n                }\n            }\n            if (aborted && !ignoreAbort && !updateCache) {\n                return fetchFail(ac.signal.reason);\n            }\n            // either we didn't abort, and are still here, or we did, and ignored\n            if (this.valList[index] === p) {\n                if (v === undefined) {\n                    if (p.__staleWhileFetching) {\n                        this.valList[index] = p.__staleWhileFetching;\n                    } else {\n                        this.delete(k);\n                    }\n                } else {\n                    if (options.status) options.status.fetchUpdated = true;\n                    this.set(k, v, fetchOpts.options);\n                }\n            }\n            return v;\n        };\n        const eb = (er)=>{\n            if (options.status) {\n                options.status.fetchRejected = true;\n                options.status.fetchError = er;\n            }\n            return fetchFail(er);\n        };\n        const fetchFail = (er)=>{\n            const { aborted } = ac.signal;\n            const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;\n            const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;\n            const noDelete = allowStale || options.noDeleteOnFetchRejection;\n            if (this.valList[index] === p) {\n                // if we allow stale on fetch rejections, then we need to ensure that\n                // the stale value is not removed from the cache when the fetch fails.\n                const del = !noDelete || p.__staleWhileFetching === undefined;\n                if (del) {\n                    this.delete(k);\n                } else if (!allowStaleAborted) {\n                    // still replace the *promise* with the stale value,\n                    // since we are done with the promise at this point.\n                    // leave it untouched if we're still waiting for an\n                    // aborted background fetch that hasn't yet returned.\n                    this.valList[index] = p.__staleWhileFetching;\n                }\n            }\n            if (allowStale) {\n                if (options.status && p.__staleWhileFetching !== undefined) {\n                    options.status.returnedStale = true;\n                }\n                return p.__staleWhileFetching;\n            } else if (p.__returned === p) {\n                throw er;\n            }\n        };\n        const pcall = (res, rej)=>{\n            this.fetchMethod(k, v, fetchOpts).then((v)=>res(v), rej);\n            // ignored, we go until we finish, regardless.\n            // defer check until we are actually aborting,\n            // so fetchMethod can override.\n            ac.signal.addEventListener(\"abort\", ()=>{\n                if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {\n                    res();\n                    // when it eventually resolves, update the cache.\n                    if (options.allowStaleOnFetchAbort) {\n                        res = (v)=>cb(v, true);\n                    }\n                }\n            });\n        };\n        if (options.status) options.status.fetchDispatched = true;\n        const p = new Promise(pcall).then(cb, eb);\n        p.__abortController = ac;\n        p.__staleWhileFetching = v;\n        p.__returned = null;\n        if (index === undefined) {\n            // internal, don't expose status.\n            this.set(k, p, {\n                ...fetchOpts.options,\n                status: undefined\n            });\n            index = this.keyMap.get(k);\n        } else {\n            this.valList[index] = p;\n        }\n        return p;\n    }\n    isBackgroundFetch(p) {\n        return p && typeof p === \"object\" && typeof p.then === \"function\" && Object.prototype.hasOwnProperty.call(p, \"__staleWhileFetching\") && Object.prototype.hasOwnProperty.call(p, \"__returned\") && (p.__returned === p || p.__returned === null);\n    }\n    // this takes the union of get() and set() opts, because it does both\n    async fetch(k, { // get options\n    allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, // set options\n    ttl = this.ttl, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, // fetch exclusive options\n    noDeleteOnFetchRejection = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection = this.allowStaleOnFetchRejection, ignoreFetchAbort = this.ignoreFetchAbort, allowStaleOnFetchAbort = this.allowStaleOnFetchAbort, fetchContext = this.fetchContext, forceRefresh = false, status, signal } = {}) {\n        if (!this.fetchMethod) {\n            if (status) status.fetch = \"get\";\n            return this.get(k, {\n                allowStale,\n                updateAgeOnGet,\n                noDeleteOnStaleGet,\n                status\n            });\n        }\n        const options = {\n            allowStale,\n            updateAgeOnGet,\n            noDeleteOnStaleGet,\n            ttl,\n            noDisposeOnSet,\n            size,\n            sizeCalculation,\n            noUpdateTTL,\n            noDeleteOnFetchRejection,\n            allowStaleOnFetchRejection,\n            allowStaleOnFetchAbort,\n            ignoreFetchAbort,\n            status,\n            signal\n        };\n        let index = this.keyMap.get(k);\n        if (index === undefined) {\n            if (status) status.fetch = \"miss\";\n            const p = this.backgroundFetch(k, index, options, fetchContext);\n            return p.__returned = p;\n        } else {\n            // in cache, maybe already fetching\n            const v = this.valList[index];\n            if (this.isBackgroundFetch(v)) {\n                const stale = allowStale && v.__staleWhileFetching !== undefined;\n                if (status) {\n                    status.fetch = \"inflight\";\n                    if (stale) status.returnedStale = true;\n                }\n                return stale ? v.__staleWhileFetching : v.__returned = v;\n            }\n            // if we force a refresh, that means do NOT serve the cached value,\n            // unless we are already in the process of refreshing the cache.\n            const isStale = this.isStale(index);\n            if (!forceRefresh && !isStale) {\n                if (status) status.fetch = \"hit\";\n                this.moveToTail(index);\n                if (updateAgeOnGet) {\n                    this.updateItemAge(index);\n                }\n                this.statusTTL(status, index);\n                return v;\n            }\n            // ok, it is stale or a forced refresh, and not already fetching.\n            // refresh the cache.\n            const p = this.backgroundFetch(k, index, options, fetchContext);\n            const hasStale = p.__staleWhileFetching !== undefined;\n            const staleVal = hasStale && allowStale;\n            if (status) {\n                status.fetch = hasStale && isStale ? \"stale\" : \"refresh\";\n                if (staleVal && isStale) status.returnedStale = true;\n            }\n            return staleVal ? p.__staleWhileFetching : p.__returned = p;\n        }\n    }\n    get(k, { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = {}) {\n        const index = this.keyMap.get(k);\n        if (index !== undefined) {\n            const value = this.valList[index];\n            const fetching = this.isBackgroundFetch(value);\n            this.statusTTL(status, index);\n            if (this.isStale(index)) {\n                if (status) status.get = \"stale\";\n                // delete only if not an in-flight background fetch\n                if (!fetching) {\n                    if (!noDeleteOnStaleGet) {\n                        this.delete(k);\n                    }\n                    if (status) status.returnedStale = allowStale;\n                    return allowStale ? value : undefined;\n                } else {\n                    if (status) {\n                        status.returnedStale = allowStale && value.__staleWhileFetching !== undefined;\n                    }\n                    return allowStale ? value.__staleWhileFetching : undefined;\n                }\n            } else {\n                if (status) status.get = \"hit\";\n                // if we're currently fetching it, we don't actually have it yet\n                // it's not stale, which means this isn't a staleWhileRefetching.\n                // If it's not stale, and fetching, AND has a __staleWhileFetching\n                // value, then that means the user fetched with {forceRefresh:true},\n                // so it's safe to return that value.\n                if (fetching) {\n                    return value.__staleWhileFetching;\n                }\n                this.moveToTail(index);\n                if (updateAgeOnGet) {\n                    this.updateItemAge(index);\n                }\n                return value;\n            }\n        } else if (status) {\n            status.get = \"miss\";\n        }\n    }\n    connect(p, n) {\n        this.prev[n] = p;\n        this.next[p] = n;\n    }\n    moveToTail(index) {\n        // if tail already, nothing to do\n        // if head, move head to next[index]\n        // else\n        //   move next[prev[index]] to next[index] (head has no prev)\n        //   move prev[next[index]] to prev[index]\n        // prev[index] = tail\n        // next[tail] = index\n        // tail = index\n        if (index !== this.tail) {\n            if (index === this.head) {\n                this.head = this.next[index];\n            } else {\n                this.connect(this.prev[index], this.next[index]);\n            }\n            this.connect(this.tail, index);\n            this.tail = index;\n        }\n    }\n    get del() {\n        deprecatedMethod(\"del\", \"delete\");\n        return this.delete;\n    }\n    delete(k) {\n        let deleted = false;\n        if (this.size !== 0) {\n            const index = this.keyMap.get(k);\n            if (index !== undefined) {\n                deleted = true;\n                if (this.size === 1) {\n                    this.clear();\n                } else {\n                    this.removeItemSize(index);\n                    const v = this.valList[index];\n                    if (this.isBackgroundFetch(v)) {\n                        v.__abortController.abort(new Error(\"deleted\"));\n                    } else {\n                        this.dispose(v, k, \"delete\");\n                        if (this.disposeAfter) {\n                            this.disposed.push([\n                                v,\n                                k,\n                                \"delete\"\n                            ]);\n                        }\n                    }\n                    this.keyMap.delete(k);\n                    this.keyList[index] = null;\n                    this.valList[index] = null;\n                    if (index === this.tail) {\n                        this.tail = this.prev[index];\n                    } else if (index === this.head) {\n                        this.head = this.next[index];\n                    } else {\n                        this.next[this.prev[index]] = this.next[index];\n                        this.prev[this.next[index]] = this.prev[index];\n                    }\n                    this.size--;\n                    this.free.push(index);\n                }\n            }\n        }\n        if (this.disposed) {\n            while(this.disposed.length){\n                this.disposeAfter(...this.disposed.shift());\n            }\n        }\n        return deleted;\n    }\n    clear() {\n        for (const index of this.rindexes({\n            allowStale: true\n        })){\n            const v = this.valList[index];\n            if (this.isBackgroundFetch(v)) {\n                v.__abortController.abort(new Error(\"deleted\"));\n            } else {\n                const k = this.keyList[index];\n                this.dispose(v, k, \"delete\");\n                if (this.disposeAfter) {\n                    this.disposed.push([\n                        v,\n                        k,\n                        \"delete\"\n                    ]);\n                }\n            }\n        }\n        this.keyMap.clear();\n        this.valList.fill(null);\n        this.keyList.fill(null);\n        if (this.ttls) {\n            this.ttls.fill(0);\n            this.starts.fill(0);\n        }\n        if (this.sizes) {\n            this.sizes.fill(0);\n        }\n        this.head = 0;\n        this.tail = 0;\n        this.initialFill = 1;\n        this.free.length = 0;\n        this.calculatedSize = 0;\n        this.size = 0;\n        if (this.disposed) {\n            while(this.disposed.length){\n                this.disposeAfter(...this.disposed.shift());\n            }\n        }\n    }\n    get reset() {\n        deprecatedMethod(\"reset\", \"clear\");\n        return this.clear;\n    }\n    get length() {\n        deprecatedProperty(\"length\", \"size\");\n        return this.size;\n    }\n    static get AbortController() {\n        return AC;\n    }\n    static get AbortSignal() {\n        return AS;\n    }\n}\nmodule.exports = LRUCache;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb3J0dWd1ZXNlLXF1b3RlLWNhcmQvLi9ub2RlX21vZHVsZXMvbmFtZWQtcGxhY2Vob2xkZXJzL25vZGVfbW9kdWxlcy9scnUtY2FjaGUvaW5kZXguanM/MWRhNSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBwZXJmID1cbiAgdHlwZW9mIHBlcmZvcm1hbmNlID09PSAnb2JqZWN0JyAmJlxuICBwZXJmb3JtYW5jZSAmJlxuICB0eXBlb2YgcGVyZm9ybWFuY2Uubm93ID09PSAnZnVuY3Rpb24nXG4gICAgPyBwZXJmb3JtYW5jZVxuICAgIDogRGF0ZVxuXG5jb25zdCBoYXNBYm9ydENvbnRyb2xsZXIgPSB0eXBlb2YgQWJvcnRDb250cm9sbGVyID09PSAnZnVuY3Rpb24nXG5cbi8vIG1pbmltYWwgYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgcG9seWZpbGxcbi8vIHRoaXMgZG9lc24ndCBoYXZlIG5lYXJseSBhbGwgdGhlIGNoZWNrcyBhbmQgd2hhdG5vdCB0aGF0XG4vLyBhY3R1YWwgQWJvcnRDb250cm9sbGVyL1NpZ25hbCBoYXMsIGJ1dCBpdCdzIGVub3VnaCBmb3Jcbi8vIG91ciBwdXJwb3NlcywgYW5kIGlmIHVzZWQgcHJvcGVybHksIGJlaGF2ZXMgdGhlIHNhbWUuXG5jb25zdCBBQyA9IGhhc0Fib3J0Q29udHJvbGxlclxuICA/IEFib3J0Q29udHJvbGxlclxuICA6IGNsYXNzIEFib3J0Q29udHJvbGxlciB7XG4gICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zaWduYWwgPSBuZXcgQVMoKVxuICAgICAgfVxuICAgICAgYWJvcnQocmVhc29uID0gbmV3IEVycm9yKCdUaGlzIG9wZXJhdGlvbiB3YXMgYWJvcnRlZCcpKSB7XG4gICAgICAgIHRoaXMuc2lnbmFsLnJlYXNvbiA9IHRoaXMuc2lnbmFsLnJlYXNvbiB8fCByZWFzb25cbiAgICAgICAgdGhpcy5zaWduYWwuYWJvcnRlZCA9IHRydWVcbiAgICAgICAgdGhpcy5zaWduYWwuZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgdHlwZTogJ2Fib3J0JyxcbiAgICAgICAgICB0YXJnZXQ6IHRoaXMuc2lnbmFsLFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cblxuY29uc3QgaGFzQWJvcnRTaWduYWwgPSB0eXBlb2YgQWJvcnRTaWduYWwgPT09ICdmdW5jdGlvbidcbi8vIFNvbWUgcG9seWZpbGxzIHB1dCB0aGlzIG9uIHRoZSBBQyBjbGFzcywgbm90IGdsb2JhbFxuY29uc3QgaGFzQUNBYm9ydFNpZ25hbCA9IHR5cGVvZiBBQy5BYm9ydFNpZ25hbCA9PT0gJ2Z1bmN0aW9uJ1xuY29uc3QgQVMgPSBoYXNBYm9ydFNpZ25hbFxuICA/IEFib3J0U2lnbmFsXG4gIDogaGFzQUNBYm9ydFNpZ25hbFxuICA/IEFDLkFib3J0Q29udHJvbGxlclxuICA6IGNsYXNzIEFib3J0U2lnbmFsIHtcbiAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnJlYXNvbiA9IHVuZGVmaW5lZFxuICAgICAgICB0aGlzLmFib3J0ZWQgPSBmYWxzZVxuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSBbXVxuICAgICAgfVxuICAgICAgZGlzcGF0Y2hFdmVudChlKSB7XG4gICAgICAgIGlmIChlLnR5cGUgPT09ICdhYm9ydCcpIHtcbiAgICAgICAgICB0aGlzLmFib3J0ZWQgPSB0cnVlXG4gICAgICAgICAgdGhpcy5vbmFib3J0KGUpXG4gICAgICAgICAgdGhpcy5fbGlzdGVuZXJzLmZvckVhY2goZiA9PiBmKGUpLCB0aGlzKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvbmFib3J0KCkge31cbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZXYsIGZuKSB7XG4gICAgICAgIGlmIChldiA9PT0gJ2Fib3J0Jykge1xuICAgICAgICAgIHRoaXMuX2xpc3RlbmVycy5wdXNoKGZuKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZW1vdmVFdmVudExpc3RlbmVyKGV2LCBmbikge1xuICAgICAgICBpZiAoZXYgPT09ICdhYm9ydCcpIHtcbiAgICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnMuZmlsdGVyKGYgPT4gZiAhPT0gZm4pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbmNvbnN0IHdhcm5lZCA9IG5ldyBTZXQoKVxuY29uc3QgZGVwcmVjYXRlZE9wdGlvbiA9IChvcHQsIGluc3RlYWQpID0+IHtcbiAgY29uc3QgY29kZSA9IGBMUlVfQ0FDSEVfT1BUSU9OXyR7b3B0fWBcbiAgaWYgKHNob3VsZFdhcm4oY29kZSkpIHtcbiAgICB3YXJuKGNvZGUsIGAke29wdH0gb3B0aW9uYCwgYG9wdGlvbnMuJHtpbnN0ZWFkfWAsIExSVUNhY2hlKVxuICB9XG59XG5jb25zdCBkZXByZWNhdGVkTWV0aG9kID0gKG1ldGhvZCwgaW5zdGVhZCkgPT4ge1xuICBjb25zdCBjb2RlID0gYExSVV9DQUNIRV9NRVRIT0RfJHttZXRob2R9YFxuICBpZiAoc2hvdWxkV2Fybihjb2RlKSkge1xuICAgIGNvbnN0IHsgcHJvdG90eXBlIH0gPSBMUlVDYWNoZVxuICAgIGNvbnN0IHsgZ2V0IH0gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvdHlwZSwgbWV0aG9kKVxuICAgIHdhcm4oY29kZSwgYCR7bWV0aG9kfSBtZXRob2RgLCBgY2FjaGUuJHtpbnN0ZWFkfSgpYCwgZ2V0KVxuICB9XG59XG5jb25zdCBkZXByZWNhdGVkUHJvcGVydHkgPSAoZmllbGQsIGluc3RlYWQpID0+IHtcbiAgY29uc3QgY29kZSA9IGBMUlVfQ0FDSEVfUFJPUEVSVFlfJHtmaWVsZH1gXG4gIGlmIChzaG91bGRXYXJuKGNvZGUpKSB7XG4gICAgY29uc3QgeyBwcm90b3R5cGUgfSA9IExSVUNhY2hlXG4gICAgY29uc3QgeyBnZXQgfSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdG90eXBlLCBmaWVsZClcbiAgICB3YXJuKGNvZGUsIGAke2ZpZWxkfSBwcm9wZXJ0eWAsIGBjYWNoZS4ke2luc3RlYWR9YCwgZ2V0KVxuICB9XG59XG5cbmNvbnN0IGVtaXRXYXJuaW5nID0gKC4uLmEpID0+IHtcbiAgdHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmXG4gIHByb2Nlc3MgJiZcbiAgdHlwZW9mIHByb2Nlc3MuZW1pdFdhcm5pbmcgPT09ICdmdW5jdGlvbidcbiAgICA/IHByb2Nlc3MuZW1pdFdhcm5pbmcoLi4uYSlcbiAgICA6IGNvbnNvbGUuZXJyb3IoLi4uYSlcbn1cblxuY29uc3Qgc2hvdWxkV2FybiA9IGNvZGUgPT4gIXdhcm5lZC5oYXMoY29kZSlcblxuY29uc3Qgd2FybiA9IChjb2RlLCB3aGF0LCBpbnN0ZWFkLCBmbikgPT4ge1xuICB3YXJuZWQuYWRkKGNvZGUpXG4gIGNvbnN0IG1zZyA9IGBUaGUgJHt3aGF0fSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlICR7aW5zdGVhZH0gaW5zdGVhZC5gXG4gIGVtaXRXYXJuaW5nKG1zZywgJ0RlcHJlY2F0aW9uV2FybmluZycsIGNvZGUsIGZuKVxufVxuXG5jb25zdCBpc1Bvc0ludCA9IG4gPT4gbiAmJiBuID09PSBNYXRoLmZsb29yKG4pICYmIG4gPiAwICYmIGlzRmluaXRlKG4pXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gVGhpcyBpcyBhIGxpdHRsZSBiaXQgcmlkaWN1bG91cywgdGJoLlxuICogVGhlIG1heGltdW0gYXJyYXkgbGVuZ3RoIGlzIDJeMzItMSBvciB0aGVyZWFib3V0cyBvbiBtb3N0IEpTIGltcGxzLlxuICogQW5kIHdlbGwgYmVmb3JlIHRoYXQgcG9pbnQsIHlvdSdyZSBjYWNoaW5nIHRoZSBlbnRpcmUgd29ybGQsIEkgbWVhbixcbiAqIHRoYXQncyB+MzJHQiBvZiBqdXN0IGludGVnZXJzIGZvciB0aGUgbmV4dC9wcmV2IGxpbmtzLCBwbHVzIHdoYXRldmVyXG4gKiBlbHNlIHRvIGhvbGQgdGhhdCBtYW55IGtleXMgYW5kIHZhbHVlcy4gIEp1c3QgZmlsbGluZyB0aGUgbWVtb3J5IHdpdGhcbiAqIHplcm9lcyBhdCBpbml0IHRpbWUgaXMgYnJ1dGFsIHdoZW4geW91IGdldCB0aGF0IGJpZy5cbiAqIEJ1dCB3aHkgbm90IGJlIGNvbXBsZXRlP1xuICogTWF5YmUgaW4gdGhlIGZ1dHVyZSwgdGhlc2UgbGltaXRzIHdpbGwgaGF2ZSBleHBhbmRlZC4gKi9cbmNvbnN0IGdldFVpbnRBcnJheSA9IG1heCA9PlxuICAhaXNQb3NJbnQobWF4KVxuICAgID8gbnVsbFxuICAgIDogbWF4IDw9IE1hdGgucG93KDIsIDgpXG4gICAgPyBVaW50OEFycmF5XG4gICAgOiBtYXggPD0gTWF0aC5wb3coMiwgMTYpXG4gICAgPyBVaW50MTZBcnJheVxuICAgIDogbWF4IDw9IE1hdGgucG93KDIsIDMyKVxuICAgID8gVWludDMyQXJyYXlcbiAgICA6IG1heCA8PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxuICAgID8gWmVyb0FycmF5XG4gICAgOiBudWxsXG5cbmNsYXNzIFplcm9BcnJheSBleHRlbmRzIEFycmF5IHtcbiAgY29uc3RydWN0b3Ioc2l6ZSkge1xuICAgIHN1cGVyKHNpemUpXG4gICAgdGhpcy5maWxsKDApXG4gIH1cbn1cblxuY2xhc3MgU3RhY2sge1xuICBjb25zdHJ1Y3RvcihtYXgpIHtcbiAgICBpZiAobWF4ID09PSAwKSB7XG4gICAgICByZXR1cm4gW11cbiAgICB9XG4gICAgY29uc3QgVWludEFycmF5ID0gZ2V0VWludEFycmF5KG1heClcbiAgICB0aGlzLmhlYXAgPSBuZXcgVWludEFycmF5KG1heClcbiAgICB0aGlzLmxlbmd0aCA9IDBcbiAgfVxuICBwdXNoKG4pIHtcbiAgICB0aGlzLmhlYXBbdGhpcy5sZW5ndGgrK10gPSBuXG4gIH1cbiAgcG9wKCkge1xuICAgIHJldHVybiB0aGlzLmhlYXBbLS10aGlzLmxlbmd0aF1cbiAgfVxufVxuXG5jbGFzcyBMUlVDYWNoZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1heCA9IDAsXG4gICAgICB0dGwsXG4gICAgICB0dGxSZXNvbHV0aW9uID0gMSxcbiAgICAgIHR0bEF1dG9wdXJnZSxcbiAgICAgIHVwZGF0ZUFnZU9uR2V0LFxuICAgICAgdXBkYXRlQWdlT25IYXMsXG4gICAgICBhbGxvd1N0YWxlLFxuICAgICAgZGlzcG9zZSxcbiAgICAgIGRpc3Bvc2VBZnRlcixcbiAgICAgIG5vRGlzcG9zZU9uU2V0LFxuICAgICAgbm9VcGRhdGVUVEwsXG4gICAgICBtYXhTaXplID0gMCxcbiAgICAgIG1heEVudHJ5U2l6ZSA9IDAsXG4gICAgICBzaXplQ2FsY3VsYXRpb24sXG4gICAgICBmZXRjaE1ldGhvZCxcbiAgICAgIGZldGNoQ29udGV4dCxcbiAgICAgIG5vRGVsZXRlT25GZXRjaFJlamVjdGlvbixcbiAgICAgIG5vRGVsZXRlT25TdGFsZUdldCxcbiAgICAgIGFsbG93U3RhbGVPbkZldGNoUmVqZWN0aW9uLFxuICAgICAgYWxsb3dTdGFsZU9uRmV0Y2hBYm9ydCxcbiAgICAgIGlnbm9yZUZldGNoQWJvcnQsXG4gICAgfSA9IG9wdGlvbnNcblxuICAgIC8vIGRlcHJlY2F0ZWQgb3B0aW9ucywgZG9uJ3QgdHJpZ2dlciBhIHdhcm5pbmcgZm9yIGdldHRpbmcgdGhlbSBpZlxuICAgIC8vIHRoZSB0aGluZyBiZWluZyBwYXNzZWQgaW4gaXMgYW5vdGhlciBMUlVDYWNoZSB3ZSdyZSBjb3B5aW5nLlxuICAgIGNvbnN0IHsgbGVuZ3RoLCBtYXhBZ2UsIHN0YWxlIH0gPVxuICAgICAgb3B0aW9ucyBpbnN0YW5jZW9mIExSVUNhY2hlID8ge30gOiBvcHRpb25zXG5cbiAgICBpZiAobWF4ICE9PSAwICYmICFpc1Bvc0ludChtYXgpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYXggb3B0aW9uIG11c3QgYmUgYSBub25uZWdhdGl2ZSBpbnRlZ2VyJylcbiAgICB9XG5cbiAgICBjb25zdCBVaW50QXJyYXkgPSBtYXggPyBnZXRVaW50QXJyYXkobWF4KSA6IEFycmF5XG4gICAgaWYgKCFVaW50QXJyYXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBtYXggdmFsdWU6ICcgKyBtYXgpXG4gICAgfVxuXG4gICAgdGhpcy5tYXggPSBtYXhcbiAgICB0aGlzLm1heFNpemUgPSBtYXhTaXplXG4gICAgdGhpcy5tYXhFbnRyeVNpemUgPSBtYXhFbnRyeVNpemUgfHwgdGhpcy5tYXhTaXplXG4gICAgdGhpcy5zaXplQ2FsY3VsYXRpb24gPSBzaXplQ2FsY3VsYXRpb24gfHwgbGVuZ3RoXG4gICAgaWYgKHRoaXMuc2l6ZUNhbGN1bGF0aW9uKSB7XG4gICAgICBpZiAoIXRoaXMubWF4U2l6ZSAmJiAhdGhpcy5tYXhFbnRyeVNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnY2Fubm90IHNldCBzaXplQ2FsY3VsYXRpb24gd2l0aG91dCBzZXR0aW5nIG1heFNpemUgb3IgbWF4RW50cnlTaXplJ1xuICAgICAgICApXG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHRoaXMuc2l6ZUNhbGN1bGF0aW9uICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NpemVDYWxjdWxhdGlvbiBzZXQgdG8gbm9uLWZ1bmN0aW9uJylcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmZldGNoTWV0aG9kID0gZmV0Y2hNZXRob2QgfHwgbnVsbFxuICAgIGlmICh0aGlzLmZldGNoTWV0aG9kICYmIHR5cGVvZiB0aGlzLmZldGNoTWV0aG9kICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnZmV0Y2hNZXRob2QgbXVzdCBiZSBhIGZ1bmN0aW9uIGlmIHNwZWNpZmllZCdcbiAgICAgIClcbiAgICB9XG5cbiAgICB0aGlzLmZldGNoQ29udGV4dCA9IGZldGNoQ29udGV4dFxuICAgIGlmICghdGhpcy5mZXRjaE1ldGhvZCAmJiBmZXRjaENvbnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ2Nhbm5vdCBzZXQgZmV0Y2hDb250ZXh0IHdpdGhvdXQgZmV0Y2hNZXRob2QnXG4gICAgICApXG4gICAgfVxuXG4gICAgdGhpcy5rZXlNYXAgPSBuZXcgTWFwKClcbiAgICB0aGlzLmtleUxpc3QgPSBuZXcgQXJyYXkobWF4KS5maWxsKG51bGwpXG4gICAgdGhpcy52YWxMaXN0ID0gbmV3IEFycmF5KG1heCkuZmlsbChudWxsKVxuICAgIHRoaXMubmV4dCA9IG5ldyBVaW50QXJyYXkobWF4KVxuICAgIHRoaXMucHJldiA9IG5ldyBVaW50QXJyYXkobWF4KVxuICAgIHRoaXMuaGVhZCA9IDBcbiAgICB0aGlzLnRhaWwgPSAwXG4gICAgdGhpcy5mcmVlID0gbmV3IFN0YWNrKG1heClcbiAgICB0aGlzLmluaXRpYWxGaWxsID0gMVxuICAgIHRoaXMuc2l6ZSA9IDBcblxuICAgIGlmICh0eXBlb2YgZGlzcG9zZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5kaXNwb3NlID0gZGlzcG9zZVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGRpc3Bvc2VBZnRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5kaXNwb3NlQWZ0ZXIgPSBkaXNwb3NlQWZ0ZXJcbiAgICAgIHRoaXMuZGlzcG9zZWQgPSBbXVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRpc3Bvc2VBZnRlciA9IG51bGxcbiAgICAgIHRoaXMuZGlzcG9zZWQgPSBudWxsXG4gICAgfVxuICAgIHRoaXMubm9EaXNwb3NlT25TZXQgPSAhIW5vRGlzcG9zZU9uU2V0XG4gICAgdGhpcy5ub1VwZGF0ZVRUTCA9ICEhbm9VcGRhdGVUVExcbiAgICB0aGlzLm5vRGVsZXRlT25GZXRjaFJlamVjdGlvbiA9ICEhbm9EZWxldGVPbkZldGNoUmVqZWN0aW9uXG4gICAgdGhpcy5hbGxvd1N0YWxlT25GZXRjaFJlamVjdGlvbiA9ICEhYWxsb3dTdGFsZU9uRmV0Y2hSZWplY3Rpb25cbiAgICB0aGlzLmFsbG93U3RhbGVPbkZldGNoQWJvcnQgPSAhIWFsbG93U3RhbGVPbkZldGNoQWJvcnRcbiAgICB0aGlzLmlnbm9yZUZldGNoQWJvcnQgPSAhIWlnbm9yZUZldGNoQWJvcnRcblxuICAgIC8vIE5COiBtYXhFbnRyeVNpemUgaXMgc2V0IHRvIG1heFNpemUgaWYgaXQncyBzZXRcbiAgICBpZiAodGhpcy5tYXhFbnRyeVNpemUgIT09IDApIHtcbiAgICAgIGlmICh0aGlzLm1heFNpemUgIT09IDApIHtcbiAgICAgICAgaWYgKCFpc1Bvc0ludCh0aGlzLm1heFNpemUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICdtYXhTaXplIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIGlmIHNwZWNpZmllZCdcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghaXNQb3NJbnQodGhpcy5tYXhFbnRyeVNpemUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgJ21heEVudHJ5U2l6ZSBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBpZiBzcGVjaWZpZWQnXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5pdGlhbGl6ZVNpemVUcmFja2luZygpXG4gICAgfVxuXG4gICAgdGhpcy5hbGxvd1N0YWxlID0gISFhbGxvd1N0YWxlIHx8ICEhc3RhbGVcbiAgICB0aGlzLm5vRGVsZXRlT25TdGFsZUdldCA9ICEhbm9EZWxldGVPblN0YWxlR2V0XG4gICAgdGhpcy51cGRhdGVBZ2VPbkdldCA9ICEhdXBkYXRlQWdlT25HZXRcbiAgICB0aGlzLnVwZGF0ZUFnZU9uSGFzID0gISF1cGRhdGVBZ2VPbkhhc1xuICAgIHRoaXMudHRsUmVzb2x1dGlvbiA9XG4gICAgICBpc1Bvc0ludCh0dGxSZXNvbHV0aW9uKSB8fCB0dGxSZXNvbHV0aW9uID09PSAwXG4gICAgICAgID8gdHRsUmVzb2x1dGlvblxuICAgICAgICA6IDFcbiAgICB0aGlzLnR0bEF1dG9wdXJnZSA9ICEhdHRsQXV0b3B1cmdlXG4gICAgdGhpcy50dGwgPSB0dGwgfHwgbWF4QWdlIHx8IDBcbiAgICBpZiAodGhpcy50dGwpIHtcbiAgICAgIGlmICghaXNQb3NJbnQodGhpcy50dGwpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgJ3R0bCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBpZiBzcGVjaWZpZWQnXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5pdGlhbGl6ZVRUTFRyYWNraW5nKClcbiAgICB9XG5cbiAgICAvLyBkbyBub3QgYWxsb3cgY29tcGxldGVseSB1bmJvdW5kZWQgY2FjaGVzXG4gICAgaWYgKHRoaXMubWF4ID09PSAwICYmIHRoaXMudHRsID09PSAwICYmIHRoaXMubWF4U2l6ZSA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ0F0IGxlYXN0IG9uZSBvZiBtYXgsIG1heFNpemUsIG9yIHR0bCBpcyByZXF1aXJlZCdcbiAgICAgIClcbiAgICB9XG4gICAgaWYgKCF0aGlzLnR0bEF1dG9wdXJnZSAmJiAhdGhpcy5tYXggJiYgIXRoaXMubWF4U2l6ZSkge1xuICAgICAgY29uc3QgY29kZSA9ICdMUlVfQ0FDSEVfVU5CT1VOREVEJ1xuICAgICAgaWYgKHNob3VsZFdhcm4oY29kZSkpIHtcbiAgICAgICAgd2FybmVkLmFkZChjb2RlKVxuICAgICAgICBjb25zdCBtc2cgPVxuICAgICAgICAgICdUVEwgY2FjaGluZyB3aXRob3V0IHR0bEF1dG9wdXJnZSwgbWF4LCBvciBtYXhTaXplIGNhbiAnICtcbiAgICAgICAgICAncmVzdWx0IGluIHVuYm91bmRlZCBtZW1vcnkgY29uc3VtcHRpb24uJ1xuICAgICAgICBlbWl0V2FybmluZyhtc2csICdVbmJvdW5kZWRDYWNoZVdhcm5pbmcnLCBjb2RlLCBMUlVDYWNoZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3RhbGUpIHtcbiAgICAgIGRlcHJlY2F0ZWRPcHRpb24oJ3N0YWxlJywgJ2FsbG93U3RhbGUnKVxuICAgIH1cbiAgICBpZiAobWF4QWdlKSB7XG4gICAgICBkZXByZWNhdGVkT3B0aW9uKCdtYXhBZ2UnLCAndHRsJylcbiAgICB9XG4gICAgaWYgKGxlbmd0aCkge1xuICAgICAgZGVwcmVjYXRlZE9wdGlvbignbGVuZ3RoJywgJ3NpemVDYWxjdWxhdGlvbicpXG4gICAgfVxuICB9XG5cbiAgZ2V0UmVtYWluaW5nVFRMKGtleSkge1xuICAgIHJldHVybiB0aGlzLmhhcyhrZXksIHsgdXBkYXRlQWdlT25IYXM6IGZhbHNlIH0pID8gSW5maW5pdHkgOiAwXG4gIH1cblxuICBpbml0aWFsaXplVFRMVHJhY2tpbmcoKSB7XG4gICAgdGhpcy50dGxzID0gbmV3IFplcm9BcnJheSh0aGlzLm1heClcbiAgICB0aGlzLnN0YXJ0cyA9IG5ldyBaZXJvQXJyYXkodGhpcy5tYXgpXG5cbiAgICB0aGlzLnNldEl0ZW1UVEwgPSAoaW5kZXgsIHR0bCwgc3RhcnQgPSBwZXJmLm5vdygpKSA9PiB7XG4gICAgICB0aGlzLnN0YXJ0c1tpbmRleF0gPSB0dGwgIT09IDAgPyBzdGFydCA6IDBcbiAgICAgIHRoaXMudHRsc1tpbmRleF0gPSB0dGxcbiAgICAgIGlmICh0dGwgIT09IDAgJiYgdGhpcy50dGxBdXRvcHVyZ2UpIHtcbiAgICAgICAgY29uc3QgdCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmlzU3RhbGUoaW5kZXgpKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGV0ZSh0aGlzLmtleUxpc3RbaW5kZXhdKVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgdHRsICsgMSlcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgLSB1bnJlZigpIG5vdCBzdXBwb3J0ZWQgb24gYWxsIHBsYXRmb3JtcyAqL1xuICAgICAgICBpZiAodC51bnJlZikge1xuICAgICAgICAgIHQudW5yZWYoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVJdGVtQWdlID0gaW5kZXggPT4ge1xuICAgICAgdGhpcy5zdGFydHNbaW5kZXhdID0gdGhpcy50dGxzW2luZGV4XSAhPT0gMCA/IHBlcmYubm93KCkgOiAwXG4gICAgfVxuXG4gICAgdGhpcy5zdGF0dXNUVEwgPSAoc3RhdHVzLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKHN0YXR1cykge1xuICAgICAgICBzdGF0dXMudHRsID0gdGhpcy50dGxzW2luZGV4XVxuICAgICAgICBzdGF0dXMuc3RhcnQgPSB0aGlzLnN0YXJ0c1tpbmRleF1cbiAgICAgICAgc3RhdHVzLm5vdyA9IGNhY2hlZE5vdyB8fCBnZXROb3coKVxuICAgICAgICBzdGF0dXMucmVtYWluaW5nVFRMID0gc3RhdHVzLm5vdyArIHN0YXR1cy50dGwgLSBzdGF0dXMuc3RhcnRcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkZWJvdW5jZSBjYWxscyB0byBwZXJmLm5vdygpIHRvIDFzIHNvIHdlJ3JlIG5vdCBoaXR0aW5nXG4gICAgLy8gdGhhdCBjb3N0bHkgY2FsbCByZXBlYXRlZGx5LlxuICAgIGxldCBjYWNoZWROb3cgPSAwXG4gICAgY29uc3QgZ2V0Tm93ID0gKCkgPT4ge1xuICAgICAgY29uc3QgbiA9IHBlcmYubm93KClcbiAgICAgIGlmICh0aGlzLnR0bFJlc29sdXRpb24gPiAwKSB7XG4gICAgICAgIGNhY2hlZE5vdyA9IG5cbiAgICAgICAgY29uc3QgdCA9IHNldFRpbWVvdXQoXG4gICAgICAgICAgKCkgPT4gKGNhY2hlZE5vdyA9IDApLFxuICAgICAgICAgIHRoaXMudHRsUmVzb2x1dGlvblxuICAgICAgICApXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlIC0gbm90IGF2YWlsYWJsZSBvbiBhbGwgcGxhdGZvcm1zICovXG4gICAgICAgIGlmICh0LnVucmVmKSB7XG4gICAgICAgICAgdC51bnJlZigpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuXG4gICAgfVxuXG4gICAgdGhpcy5nZXRSZW1haW5pbmdUVEwgPSBrZXkgPT4ge1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmtleU1hcC5nZXQoa2V5KVxuICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIDBcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnR0bHNbaW5kZXhdID09PSAwIHx8IHRoaXMuc3RhcnRzW2luZGV4XSA9PT0gMFxuICAgICAgICA/IEluZmluaXR5XG4gICAgICAgIDogdGhpcy5zdGFydHNbaW5kZXhdICtcbiAgICAgICAgICAgIHRoaXMudHRsc1tpbmRleF0gLVxuICAgICAgICAgICAgKGNhY2hlZE5vdyB8fCBnZXROb3coKSlcbiAgICB9XG5cbiAgICB0aGlzLmlzU3RhbGUgPSBpbmRleCA9PiB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICB0aGlzLnR0bHNbaW5kZXhdICE9PSAwICYmXG4gICAgICAgIHRoaXMuc3RhcnRzW2luZGV4XSAhPT0gMCAmJlxuICAgICAgICAoY2FjaGVkTm93IHx8IGdldE5vdygpKSAtIHRoaXMuc3RhcnRzW2luZGV4XSA+XG4gICAgICAgICAgdGhpcy50dGxzW2luZGV4XVxuICAgICAgKVxuICAgIH1cbiAgfVxuICB1cGRhdGVJdGVtQWdlKF9pbmRleCkge31cbiAgc3RhdHVzVFRMKF9zdGF0dXMsIF9pbmRleCkge31cbiAgc2V0SXRlbVRUTChfaW5kZXgsIF90dGwsIF9zdGFydCkge31cbiAgaXNTdGFsZShfaW5kZXgpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGluaXRpYWxpemVTaXplVHJhY2tpbmcoKSB7XG4gICAgdGhpcy5jYWxjdWxhdGVkU2l6ZSA9IDBcbiAgICB0aGlzLnNpemVzID0gbmV3IFplcm9BcnJheSh0aGlzLm1heClcbiAgICB0aGlzLnJlbW92ZUl0ZW1TaXplID0gaW5kZXggPT4ge1xuICAgICAgdGhpcy5jYWxjdWxhdGVkU2l6ZSAtPSB0aGlzLnNpemVzW2luZGV4XVxuICAgICAgdGhpcy5zaXplc1tpbmRleF0gPSAwXG4gICAgfVxuICAgIHRoaXMucmVxdWlyZVNpemUgPSAoaywgdiwgc2l6ZSwgc2l6ZUNhbGN1bGF0aW9uKSA9PiB7XG4gICAgICAvLyBwcm92aXNpb25hbGx5IGFjY2VwdCBiYWNrZ3JvdW5kIGZldGNoZXMuXG4gICAgICAvLyBhY3R1YWwgdmFsdWUgc2l6ZSB3aWxsIGJlIGNoZWNrZWQgd2hlbiB0aGV5IHJldHVybi5cbiAgICAgIGlmICh0aGlzLmlzQmFja2dyb3VuZEZldGNoKHYpKSB7XG4gICAgICAgIHJldHVybiAwXG4gICAgICB9XG4gICAgICBpZiAoIWlzUG9zSW50KHNpemUpKSB7XG4gICAgICAgIGlmIChzaXplQ2FsY3VsYXRpb24pIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHNpemVDYWxjdWxhdGlvbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc2l6ZUNhbGN1bGF0aW9uIG11c3QgYmUgYSBmdW5jdGlvbicpXG4gICAgICAgICAgfVxuICAgICAgICAgIHNpemUgPSBzaXplQ2FsY3VsYXRpb24odiwgaylcbiAgICAgICAgICBpZiAoIWlzUG9zSW50KHNpemUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAnc2l6ZUNhbGN1bGF0aW9uIHJldHVybiBpbnZhbGlkIChleHBlY3QgcG9zaXRpdmUgaW50ZWdlciknXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAnaW52YWxpZCBzaXplIHZhbHVlIChtdXN0IGJlIHBvc2l0aXZlIGludGVnZXIpLiAnICtcbiAgICAgICAgICAgICAgJ1doZW4gbWF4U2l6ZSBvciBtYXhFbnRyeVNpemUgaXMgdXNlZCwgc2l6ZUNhbGN1bGF0aW9uIG9yIHNpemUgJyArXG4gICAgICAgICAgICAgICdtdXN0IGJlIHNldC4nXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2l6ZVxuICAgIH1cbiAgICB0aGlzLmFkZEl0ZW1TaXplID0gKGluZGV4LCBzaXplLCBzdGF0dXMpID0+IHtcbiAgICAgIHRoaXMuc2l6ZXNbaW5kZXhdID0gc2l6ZVxuICAgICAgaWYgKHRoaXMubWF4U2l6ZSkge1xuICAgICAgICBjb25zdCBtYXhTaXplID0gdGhpcy5tYXhTaXplIC0gdGhpcy5zaXplc1tpbmRleF1cbiAgICAgICAgd2hpbGUgKHRoaXMuY2FsY3VsYXRlZFNpemUgPiBtYXhTaXplKSB7XG4gICAgICAgICAgdGhpcy5ldmljdCh0cnVlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmNhbGN1bGF0ZWRTaXplICs9IHRoaXMuc2l6ZXNbaW5kZXhdXG4gICAgICBpZiAoc3RhdHVzKSB7XG4gICAgICAgIHN0YXR1cy5lbnRyeVNpemUgPSBzaXplXG4gICAgICAgIHN0YXR1cy50b3RhbENhbGN1bGF0ZWRTaXplID0gdGhpcy5jYWxjdWxhdGVkU2l6ZVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZW1vdmVJdGVtU2l6ZShfaW5kZXgpIHt9XG4gIGFkZEl0ZW1TaXplKF9pbmRleCwgX3NpemUpIHt9XG4gIHJlcXVpcmVTaXplKF9rLCBfdiwgc2l6ZSwgc2l6ZUNhbGN1bGF0aW9uKSB7XG4gICAgaWYgKHNpemUgfHwgc2l6ZUNhbGN1bGF0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnY2Fubm90IHNldCBzaXplIHdpdGhvdXQgc2V0dGluZyBtYXhTaXplIG9yIG1heEVudHJ5U2l6ZSBvbiBjYWNoZSdcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICAqaW5kZXhlcyh7IGFsbG93U3RhbGUgPSB0aGlzLmFsbG93U3RhbGUgfSA9IHt9KSB7XG4gICAgaWYgKHRoaXMuc2l6ZSkge1xuICAgICAgZm9yIChsZXQgaSA9IHRoaXMudGFpbDsgdHJ1ZTsgKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkSW5kZXgoaSkpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbGxvd1N0YWxlIHx8ICF0aGlzLmlzU3RhbGUoaSkpIHtcbiAgICAgICAgICB5aWVsZCBpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPT09IHRoaXMuaGVhZCkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaSA9IHRoaXMucHJldltpXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgKnJpbmRleGVzKHsgYWxsb3dTdGFsZSA9IHRoaXMuYWxsb3dTdGFsZSB9ID0ge30pIHtcbiAgICBpZiAodGhpcy5zaXplKSB7XG4gICAgICBmb3IgKGxldCBpID0gdGhpcy5oZWFkOyB0cnVlOyApIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWRJbmRleChpKSkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsbG93U3RhbGUgfHwgIXRoaXMuaXNTdGFsZShpKSkge1xuICAgICAgICAgIHlpZWxkIGlcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA9PT0gdGhpcy50YWlsKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpID0gdGhpcy5uZXh0W2ldXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpc1ZhbGlkSW5kZXgoaW5kZXgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgaW5kZXggIT09IHVuZGVmaW5lZCAmJlxuICAgICAgdGhpcy5rZXlNYXAuZ2V0KHRoaXMua2V5TGlzdFtpbmRleF0pID09PSBpbmRleFxuICAgIClcbiAgfVxuXG4gICplbnRyaWVzKCkge1xuICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLmluZGV4ZXMoKSkge1xuICAgICAgaWYgKFxuICAgICAgICB0aGlzLnZhbExpc3RbaV0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICB0aGlzLmtleUxpc3RbaV0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAhdGhpcy5pc0JhY2tncm91bmRGZXRjaCh0aGlzLnZhbExpc3RbaV0pXG4gICAgICApIHtcbiAgICAgICAgeWllbGQgW3RoaXMua2V5TGlzdFtpXSwgdGhpcy52YWxMaXN0W2ldXVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAqcmVudHJpZXMoKSB7XG4gICAgZm9yIChjb25zdCBpIG9mIHRoaXMucmluZGV4ZXMoKSkge1xuICAgICAgaWYgKFxuICAgICAgICB0aGlzLnZhbExpc3RbaV0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICB0aGlzLmtleUxpc3RbaV0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAhdGhpcy5pc0JhY2tncm91bmRGZXRjaCh0aGlzLnZhbExpc3RbaV0pXG4gICAgICApIHtcbiAgICAgICAgeWllbGQgW3RoaXMua2V5TGlzdFtpXSwgdGhpcy52YWxMaXN0W2ldXVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gICprZXlzKCkge1xuICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLmluZGV4ZXMoKSkge1xuICAgICAgaWYgKFxuICAgICAgICB0aGlzLmtleUxpc3RbaV0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAhdGhpcy5pc0JhY2tncm91bmRGZXRjaCh0aGlzLnZhbExpc3RbaV0pXG4gICAgICApIHtcbiAgICAgICAgeWllbGQgdGhpcy5rZXlMaXN0W2ldXG4gICAgICB9XG4gICAgfVxuICB9XG4gICpya2V5cygpIHtcbiAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy5yaW5kZXhlcygpKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMua2V5TGlzdFtpXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICF0aGlzLmlzQmFja2dyb3VuZEZldGNoKHRoaXMudmFsTGlzdFtpXSlcbiAgICAgICkge1xuICAgICAgICB5aWVsZCB0aGlzLmtleUxpc3RbaV1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAqdmFsdWVzKCkge1xuICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLmluZGV4ZXMoKSkge1xuICAgICAgaWYgKFxuICAgICAgICB0aGlzLnZhbExpc3RbaV0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAhdGhpcy5pc0JhY2tncm91bmRGZXRjaCh0aGlzLnZhbExpc3RbaV0pXG4gICAgICApIHtcbiAgICAgICAgeWllbGQgdGhpcy52YWxMaXN0W2ldXG4gICAgICB9XG4gICAgfVxuICB9XG4gICpydmFsdWVzKCkge1xuICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLnJpbmRleGVzKCkpIHtcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy52YWxMaXN0W2ldICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgIXRoaXMuaXNCYWNrZ3JvdW5kRmV0Y2godGhpcy52YWxMaXN0W2ldKVxuICAgICAgKSB7XG4gICAgICAgIHlpZWxkIHRoaXMudmFsTGlzdFtpXVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiB0aGlzLmVudHJpZXMoKVxuICB9XG5cbiAgZmluZChmbiwgZ2V0T3B0aW9ucykge1xuICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLmluZGV4ZXMoKSkge1xuICAgICAgY29uc3QgdiA9IHRoaXMudmFsTGlzdFtpXVxuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmlzQmFja2dyb3VuZEZldGNoKHYpXG4gICAgICAgID8gdi5fX3N0YWxlV2hpbGVGZXRjaGluZ1xuICAgICAgICA6IHZcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSBjb250aW51ZVxuICAgICAgaWYgKGZuKHZhbHVlLCB0aGlzLmtleUxpc3RbaV0sIHRoaXMpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldCh0aGlzLmtleUxpc3RbaV0sIGdldE9wdGlvbnMpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm9yRWFjaChmbiwgdGhpc3AgPSB0aGlzKSB7XG4gICAgZm9yIChjb25zdCBpIG9mIHRoaXMuaW5kZXhlcygpKSB7XG4gICAgICBjb25zdCB2ID0gdGhpcy52YWxMaXN0W2ldXG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuaXNCYWNrZ3JvdW5kRmV0Y2godilcbiAgICAgICAgPyB2Ll9fc3RhbGVXaGlsZUZldGNoaW5nXG4gICAgICAgIDogdlxuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIGNvbnRpbnVlXG4gICAgICBmbi5jYWxsKHRoaXNwLCB2YWx1ZSwgdGhpcy5rZXlMaXN0W2ldLCB0aGlzKVxuICAgIH1cbiAgfVxuXG4gIHJmb3JFYWNoKGZuLCB0aGlzcCA9IHRoaXMpIHtcbiAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy5yaW5kZXhlcygpKSB7XG4gICAgICBjb25zdCB2ID0gdGhpcy52YWxMaXN0W2ldXG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuaXNCYWNrZ3JvdW5kRmV0Y2godilcbiAgICAgICAgPyB2Ll9fc3RhbGVXaGlsZUZldGNoaW5nXG4gICAgICAgIDogdlxuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIGNvbnRpbnVlXG4gICAgICBmbi5jYWxsKHRoaXNwLCB2YWx1ZSwgdGhpcy5rZXlMaXN0W2ldLCB0aGlzKVxuICAgIH1cbiAgfVxuXG4gIGdldCBwcnVuZSgpIHtcbiAgICBkZXByZWNhdGVkTWV0aG9kKCdwcnVuZScsICdwdXJnZVN0YWxlJylcbiAgICByZXR1cm4gdGhpcy5wdXJnZVN0YWxlXG4gIH1cblxuICBwdXJnZVN0YWxlKCkge1xuICAgIGxldCBkZWxldGVkID0gZmFsc2VcbiAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy5yaW5kZXhlcyh7IGFsbG93U3RhbGU6IHRydWUgfSkpIHtcbiAgICAgIGlmICh0aGlzLmlzU3RhbGUoaSkpIHtcbiAgICAgICAgdGhpcy5kZWxldGUodGhpcy5rZXlMaXN0W2ldKVxuICAgICAgICBkZWxldGVkID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVsZXRlZFxuICB9XG5cbiAgZHVtcCgpIHtcbiAgICBjb25zdCBhcnIgPSBbXVxuICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLmluZGV4ZXMoeyBhbGxvd1N0YWxlOiB0cnVlIH0pKSB7XG4gICAgICBjb25zdCBrZXkgPSB0aGlzLmtleUxpc3RbaV1cbiAgICAgIGNvbnN0IHYgPSB0aGlzLnZhbExpc3RbaV1cbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5pc0JhY2tncm91bmRGZXRjaCh2KVxuICAgICAgICA/IHYuX19zdGFsZVdoaWxlRmV0Y2hpbmdcbiAgICAgICAgOiB2XG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgY29udGludWVcbiAgICAgIGNvbnN0IGVudHJ5ID0geyB2YWx1ZSB9XG4gICAgICBpZiAodGhpcy50dGxzKSB7XG4gICAgICAgIGVudHJ5LnR0bCA9IHRoaXMudHRsc1tpXVxuICAgICAgICAvLyBhbHdheXMgZHVtcCB0aGUgc3RhcnQgcmVsYXRpdmUgdG8gYSBwb3J0YWJsZSB0aW1lc3RhbXBcbiAgICAgICAgLy8gaXQncyBvayBmb3IgdGhpcyB0byBiZSBhIGJpdCBzbG93LCBpdCdzIGEgcmFyZSBvcGVyYXRpb24uXG4gICAgICAgIGNvbnN0IGFnZSA9IHBlcmYubm93KCkgLSB0aGlzLnN0YXJ0c1tpXVxuICAgICAgICBlbnRyeS5zdGFydCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAtIGFnZSlcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNpemVzKSB7XG4gICAgICAgIGVudHJ5LnNpemUgPSB0aGlzLnNpemVzW2ldXG4gICAgICB9XG4gICAgICBhcnIudW5zaGlmdChba2V5LCBlbnRyeV0pXG4gICAgfVxuICAgIHJldHVybiBhcnJcbiAgfVxuXG4gIGxvYWQoYXJyKSB7XG4gICAgdGhpcy5jbGVhcigpXG4gICAgZm9yIChjb25zdCBba2V5LCBlbnRyeV0gb2YgYXJyKSB7XG4gICAgICBpZiAoZW50cnkuc3RhcnQpIHtcbiAgICAgICAgLy8gZW50cnkuc3RhcnQgaXMgYSBwb3J0YWJsZSB0aW1lc3RhbXAsIGJ1dCB3ZSBtYXkgYmUgdXNpbmdcbiAgICAgICAgLy8gbm9kZSdzIHBlcmZvcm1hbmNlLm5vdygpLCBzbyBjYWxjdWxhdGUgdGhlIG9mZnNldC5cbiAgICAgICAgLy8gaXQncyBvayBmb3IgdGhpcyB0byBiZSBhIGJpdCBzbG93LCBpdCdzIGEgcmFyZSBvcGVyYXRpb24uXG4gICAgICAgIGNvbnN0IGFnZSA9IERhdGUubm93KCkgLSBlbnRyeS5zdGFydFxuICAgICAgICBlbnRyeS5zdGFydCA9IHBlcmYubm93KCkgLSBhZ2VcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0KGtleSwgZW50cnkudmFsdWUsIGVudHJ5KVxuICAgIH1cbiAgfVxuXG4gIGRpc3Bvc2UoX3YsIF9rLCBfcmVhc29uKSB7fVxuXG4gIHNldChcbiAgICBrLFxuICAgIHYsXG4gICAge1xuICAgICAgdHRsID0gdGhpcy50dGwsXG4gICAgICBzdGFydCxcbiAgICAgIG5vRGlzcG9zZU9uU2V0ID0gdGhpcy5ub0Rpc3Bvc2VPblNldCxcbiAgICAgIHNpemUgPSAwLFxuICAgICAgc2l6ZUNhbGN1bGF0aW9uID0gdGhpcy5zaXplQ2FsY3VsYXRpb24sXG4gICAgICBub1VwZGF0ZVRUTCA9IHRoaXMubm9VcGRhdGVUVEwsXG4gICAgICBzdGF0dXMsXG4gICAgfSA9IHt9XG4gICkge1xuICAgIHNpemUgPSB0aGlzLnJlcXVpcmVTaXplKGssIHYsIHNpemUsIHNpemVDYWxjdWxhdGlvbilcbiAgICAvLyBpZiB0aGUgaXRlbSBkb2Vzbid0IGZpdCwgZG9uJ3QgZG8gYW55dGhpbmdcbiAgICAvLyBOQjogbWF4RW50cnlTaXplIHNldCB0byBtYXhTaXplIGJ5IGRlZmF1bHRcbiAgICBpZiAodGhpcy5tYXhFbnRyeVNpemUgJiYgc2l6ZSA+IHRoaXMubWF4RW50cnlTaXplKSB7XG4gICAgICBpZiAoc3RhdHVzKSB7XG4gICAgICAgIHN0YXR1cy5zZXQgPSAnbWlzcydcbiAgICAgICAgc3RhdHVzLm1heEVudHJ5U2l6ZUV4Y2VlZGVkID0gdHJ1ZVxuICAgICAgfVxuICAgICAgLy8gaGF2ZSB0byBkZWxldGUsIGluIGNhc2UgYSBiYWNrZ3JvdW5kIGZldGNoIGlzIHRoZXJlIGFscmVhZHkuXG4gICAgICAvLyBpbiBub24tYXN5bmMgY2FzZXMsIHRoaXMgaXMgYSBuby1vcFxuICAgICAgdGhpcy5kZWxldGUoaylcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIGxldCBpbmRleCA9IHRoaXMuc2l6ZSA9PT0gMCA/IHVuZGVmaW5lZCA6IHRoaXMua2V5TWFwLmdldChrKVxuICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBhZGRpdGlvblxuICAgICAgaW5kZXggPSB0aGlzLm5ld0luZGV4KClcbiAgICAgIHRoaXMua2V5TGlzdFtpbmRleF0gPSBrXG4gICAgICB0aGlzLnZhbExpc3RbaW5kZXhdID0gdlxuICAgICAgdGhpcy5rZXlNYXAuc2V0KGssIGluZGV4KVxuICAgICAgdGhpcy5uZXh0W3RoaXMudGFpbF0gPSBpbmRleFxuICAgICAgdGhpcy5wcmV2W2luZGV4XSA9IHRoaXMudGFpbFxuICAgICAgdGhpcy50YWlsID0gaW5kZXhcbiAgICAgIHRoaXMuc2l6ZSsrXG4gICAgICB0aGlzLmFkZEl0ZW1TaXplKGluZGV4LCBzaXplLCBzdGF0dXMpXG4gICAgICBpZiAoc3RhdHVzKSB7XG4gICAgICAgIHN0YXR1cy5zZXQgPSAnYWRkJ1xuICAgICAgfVxuICAgICAgbm9VcGRhdGVUVEwgPSBmYWxzZVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1cGRhdGVcbiAgICAgIHRoaXMubW92ZVRvVGFpbChpbmRleClcbiAgICAgIGNvbnN0IG9sZFZhbCA9IHRoaXMudmFsTGlzdFtpbmRleF1cbiAgICAgIGlmICh2ICE9PSBvbGRWYWwpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNCYWNrZ3JvdW5kRmV0Y2gob2xkVmFsKSkge1xuICAgICAgICAgIG9sZFZhbC5fX2Fib3J0Q29udHJvbGxlci5hYm9ydChuZXcgRXJyb3IoJ3JlcGxhY2VkJykpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFub0Rpc3Bvc2VPblNldCkge1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NlKG9sZFZhbCwgaywgJ3NldCcpXG4gICAgICAgICAgICBpZiAodGhpcy5kaXNwb3NlQWZ0ZXIpIHtcbiAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlZC5wdXNoKFtvbGRWYWwsIGssICdzZXQnXSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVJdGVtU2l6ZShpbmRleClcbiAgICAgICAgdGhpcy52YWxMaXN0W2luZGV4XSA9IHZcbiAgICAgICAgdGhpcy5hZGRJdGVtU2l6ZShpbmRleCwgc2l6ZSwgc3RhdHVzKVxuICAgICAgICBpZiAoc3RhdHVzKSB7XG4gICAgICAgICAgc3RhdHVzLnNldCA9ICdyZXBsYWNlJ1xuICAgICAgICAgIGNvbnN0IG9sZFZhbHVlID1cbiAgICAgICAgICAgIG9sZFZhbCAmJiB0aGlzLmlzQmFja2dyb3VuZEZldGNoKG9sZFZhbClcbiAgICAgICAgICAgICAgPyBvbGRWYWwuX19zdGFsZVdoaWxlRmV0Y2hpbmdcbiAgICAgICAgICAgICAgOiBvbGRWYWxcbiAgICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCkgc3RhdHVzLm9sZFZhbHVlID0gb2xkVmFsdWVcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzdGF0dXMpIHtcbiAgICAgICAgc3RhdHVzLnNldCA9ICd1cGRhdGUnXG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0dGwgIT09IDAgJiYgdGhpcy50dGwgPT09IDAgJiYgIXRoaXMudHRscykge1xuICAgICAgdGhpcy5pbml0aWFsaXplVFRMVHJhY2tpbmcoKVxuICAgIH1cbiAgICBpZiAoIW5vVXBkYXRlVFRMKSB7XG4gICAgICB0aGlzLnNldEl0ZW1UVEwoaW5kZXgsIHR0bCwgc3RhcnQpXG4gICAgfVxuICAgIHRoaXMuc3RhdHVzVFRMKHN0YXR1cywgaW5kZXgpXG4gICAgaWYgKHRoaXMuZGlzcG9zZUFmdGVyKSB7XG4gICAgICB3aGlsZSAodGhpcy5kaXNwb3NlZC5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5kaXNwb3NlQWZ0ZXIoLi4udGhpcy5kaXNwb3NlZC5zaGlmdCgpKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgbmV3SW5kZXgoKSB7XG4gICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMudGFpbFxuICAgIH1cbiAgICBpZiAodGhpcy5zaXplID09PSB0aGlzLm1heCAmJiB0aGlzLm1heCAhPT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuZXZpY3QoZmFsc2UpXG4gICAgfVxuICAgIGlmICh0aGlzLmZyZWUubGVuZ3RoICE9PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5mcmVlLnBvcCgpXG4gICAgfVxuICAgIC8vIGluaXRpYWwgZmlsbCwganVzdCBrZWVwIHdyaXRpbmcgZG93biB0aGUgbGlzdFxuICAgIHJldHVybiB0aGlzLmluaXRpYWxGaWxsKytcbiAgfVxuXG4gIHBvcCgpIHtcbiAgICBpZiAodGhpcy5zaXplKSB7XG4gICAgICBjb25zdCB2YWwgPSB0aGlzLnZhbExpc3RbdGhpcy5oZWFkXVxuICAgICAgdGhpcy5ldmljdCh0cnVlKVxuICAgICAgcmV0dXJuIHZhbFxuICAgIH1cbiAgfVxuXG4gIGV2aWN0KGZyZWUpIHtcbiAgICBjb25zdCBoZWFkID0gdGhpcy5oZWFkXG4gICAgY29uc3QgayA9IHRoaXMua2V5TGlzdFtoZWFkXVxuICAgIGNvbnN0IHYgPSB0aGlzLnZhbExpc3RbaGVhZF1cbiAgICBpZiAodGhpcy5pc0JhY2tncm91bmRGZXRjaCh2KSkge1xuICAgICAgdi5fX2Fib3J0Q29udHJvbGxlci5hYm9ydChuZXcgRXJyb3IoJ2V2aWN0ZWQnKSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kaXNwb3NlKHYsIGssICdldmljdCcpXG4gICAgICBpZiAodGhpcy5kaXNwb3NlQWZ0ZXIpIHtcbiAgICAgICAgdGhpcy5kaXNwb3NlZC5wdXNoKFt2LCBrLCAnZXZpY3QnXSlcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5yZW1vdmVJdGVtU2l6ZShoZWFkKVxuICAgIC8vIGlmIHdlIGFyZW4ndCBhYm91dCB0byB1c2UgdGhlIGluZGV4LCB0aGVuIG51bGwgdGhlc2Ugb3V0XG4gICAgaWYgKGZyZWUpIHtcbiAgICAgIHRoaXMua2V5TGlzdFtoZWFkXSA9IG51bGxcbiAgICAgIHRoaXMudmFsTGlzdFtoZWFkXSA9IG51bGxcbiAgICAgIHRoaXMuZnJlZS5wdXNoKGhlYWQpXG4gICAgfVxuICAgIHRoaXMuaGVhZCA9IHRoaXMubmV4dFtoZWFkXVxuICAgIHRoaXMua2V5TWFwLmRlbGV0ZShrKVxuICAgIHRoaXMuc2l6ZS0tXG4gICAgcmV0dXJuIGhlYWRcbiAgfVxuXG4gIGhhcyhrLCB7IHVwZGF0ZUFnZU9uSGFzID0gdGhpcy51cGRhdGVBZ2VPbkhhcywgc3RhdHVzIH0gPSB7fSkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5rZXlNYXAuZ2V0KGspXG4gICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICghdGhpcy5pc1N0YWxlKGluZGV4KSkge1xuICAgICAgICBpZiAodXBkYXRlQWdlT25IYXMpIHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZUl0ZW1BZ2UoaW5kZXgpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXR1cykgc3RhdHVzLmhhcyA9ICdoaXQnXG4gICAgICAgIHRoaXMuc3RhdHVzVFRMKHN0YXR1cywgaW5kZXgpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9IGVsc2UgaWYgKHN0YXR1cykge1xuICAgICAgICBzdGF0dXMuaGFzID0gJ3N0YWxlJ1xuICAgICAgICB0aGlzLnN0YXR1c1RUTChzdGF0dXMsIGluZGV4KVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3RhdHVzKSB7XG4gICAgICBzdGF0dXMuaGFzID0gJ21pc3MnXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gbGlrZSBnZXQoKSwgYnV0IHdpdGhvdXQgYW55IExSVSB1cGRhdGluZyBvciBUVEwgZXhwaXJhdGlvblxuICBwZWVrKGssIHsgYWxsb3dTdGFsZSA9IHRoaXMuYWxsb3dTdGFsZSB9ID0ge30pIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMua2V5TWFwLmdldChrKVxuICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkICYmIChhbGxvd1N0YWxlIHx8ICF0aGlzLmlzU3RhbGUoaW5kZXgpKSkge1xuICAgICAgY29uc3QgdiA9IHRoaXMudmFsTGlzdFtpbmRleF1cbiAgICAgIC8vIGVpdGhlciBzdGFsZSBhbmQgYWxsb3dlZCwgb3IgZm9yY2luZyBhIHJlZnJlc2ggb2Ygbm9uLXN0YWxlIHZhbHVlXG4gICAgICByZXR1cm4gdGhpcy5pc0JhY2tncm91bmRGZXRjaCh2KSA/IHYuX19zdGFsZVdoaWxlRmV0Y2hpbmcgOiB2XG4gICAgfVxuICB9XG5cbiAgYmFja2dyb3VuZEZldGNoKGssIGluZGV4LCBvcHRpb25zLCBjb250ZXh0KSB7XG4gICAgY29uc3QgdiA9IGluZGV4ID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiB0aGlzLnZhbExpc3RbaW5kZXhdXG4gICAgaWYgKHRoaXMuaXNCYWNrZ3JvdW5kRmV0Y2godikpIHtcbiAgICAgIHJldHVybiB2XG4gICAgfVxuICAgIGNvbnN0IGFjID0gbmV3IEFDKClcbiAgICBpZiAob3B0aW9ucy5zaWduYWwpIHtcbiAgICAgIG9wdGlvbnMuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT5cbiAgICAgICAgYWMuYWJvcnQob3B0aW9ucy5zaWduYWwucmVhc29uKVxuICAgICAgKVxuICAgIH1cbiAgICBjb25zdCBmZXRjaE9wdHMgPSB7XG4gICAgICBzaWduYWw6IGFjLnNpZ25hbCxcbiAgICAgIG9wdGlvbnMsXG4gICAgICBjb250ZXh0LFxuICAgIH1cbiAgICBjb25zdCBjYiA9ICh2LCB1cGRhdGVDYWNoZSA9IGZhbHNlKSA9PiB7XG4gICAgICBjb25zdCB7IGFib3J0ZWQgfSA9IGFjLnNpZ25hbFxuICAgICAgY29uc3QgaWdub3JlQWJvcnQgPSBvcHRpb25zLmlnbm9yZUZldGNoQWJvcnQgJiYgdiAhPT0gdW5kZWZpbmVkXG4gICAgICBpZiAob3B0aW9ucy5zdGF0dXMpIHtcbiAgICAgICAgaWYgKGFib3J0ZWQgJiYgIXVwZGF0ZUNhY2hlKSB7XG4gICAgICAgICAgb3B0aW9ucy5zdGF0dXMuZmV0Y2hBYm9ydGVkID0gdHJ1ZVxuICAgICAgICAgIG9wdGlvbnMuc3RhdHVzLmZldGNoRXJyb3IgPSBhYy5zaWduYWwucmVhc29uXG4gICAgICAgICAgaWYgKGlnbm9yZUFib3J0KSBvcHRpb25zLnN0YXR1cy5mZXRjaEFib3J0SWdub3JlZCA9IHRydWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcHRpb25zLnN0YXR1cy5mZXRjaFJlc29sdmVkID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYWJvcnRlZCAmJiAhaWdub3JlQWJvcnQgJiYgIXVwZGF0ZUNhY2hlKSB7XG4gICAgICAgIHJldHVybiBmZXRjaEZhaWwoYWMuc2lnbmFsLnJlYXNvbilcbiAgICAgIH1cbiAgICAgIC8vIGVpdGhlciB3ZSBkaWRuJ3QgYWJvcnQsIGFuZCBhcmUgc3RpbGwgaGVyZSwgb3Igd2UgZGlkLCBhbmQgaWdub3JlZFxuICAgICAgaWYgKHRoaXMudmFsTGlzdFtpbmRleF0gPT09IHApIHtcbiAgICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChwLl9fc3RhbGVXaGlsZUZldGNoaW5nKSB7XG4gICAgICAgICAgICB0aGlzLnZhbExpc3RbaW5kZXhdID0gcC5fX3N0YWxlV2hpbGVGZXRjaGluZ1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlbGV0ZShrKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5zdGF0dXMpIG9wdGlvbnMuc3RhdHVzLmZldGNoVXBkYXRlZCA9IHRydWVcbiAgICAgICAgICB0aGlzLnNldChrLCB2LCBmZXRjaE9wdHMub3B0aW9ucylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZcbiAgICB9XG4gICAgY29uc3QgZWIgPSBlciA9PiB7XG4gICAgICBpZiAob3B0aW9ucy5zdGF0dXMpIHtcbiAgICAgICAgb3B0aW9ucy5zdGF0dXMuZmV0Y2hSZWplY3RlZCA9IHRydWVcbiAgICAgICAgb3B0aW9ucy5zdGF0dXMuZmV0Y2hFcnJvciA9IGVyXG4gICAgICB9XG4gICAgICByZXR1cm4gZmV0Y2hGYWlsKGVyKVxuICAgIH1cbiAgICBjb25zdCBmZXRjaEZhaWwgPSBlciA9PiB7XG4gICAgICBjb25zdCB7IGFib3J0ZWQgfSA9IGFjLnNpZ25hbFxuICAgICAgY29uc3QgYWxsb3dTdGFsZUFib3J0ZWQgPVxuICAgICAgICBhYm9ydGVkICYmIG9wdGlvbnMuYWxsb3dTdGFsZU9uRmV0Y2hBYm9ydFxuICAgICAgY29uc3QgYWxsb3dTdGFsZSA9XG4gICAgICAgIGFsbG93U3RhbGVBYm9ydGVkIHx8IG9wdGlvbnMuYWxsb3dTdGFsZU9uRmV0Y2hSZWplY3Rpb25cbiAgICAgIGNvbnN0IG5vRGVsZXRlID0gYWxsb3dTdGFsZSB8fCBvcHRpb25zLm5vRGVsZXRlT25GZXRjaFJlamVjdGlvblxuICAgICAgaWYgKHRoaXMudmFsTGlzdFtpbmRleF0gPT09IHApIHtcbiAgICAgICAgLy8gaWYgd2UgYWxsb3cgc3RhbGUgb24gZmV0Y2ggcmVqZWN0aW9ucywgdGhlbiB3ZSBuZWVkIHRvIGVuc3VyZSB0aGF0XG4gICAgICAgIC8vIHRoZSBzdGFsZSB2YWx1ZSBpcyBub3QgcmVtb3ZlZCBmcm9tIHRoZSBjYWNoZSB3aGVuIHRoZSBmZXRjaCBmYWlscy5cbiAgICAgICAgY29uc3QgZGVsID0gIW5vRGVsZXRlIHx8IHAuX19zdGFsZVdoaWxlRmV0Y2hpbmcgPT09IHVuZGVmaW5lZFxuICAgICAgICBpZiAoZGVsKSB7XG4gICAgICAgICAgdGhpcy5kZWxldGUoaylcbiAgICAgICAgfSBlbHNlIGlmICghYWxsb3dTdGFsZUFib3J0ZWQpIHtcbiAgICAgICAgICAvLyBzdGlsbCByZXBsYWNlIHRoZSAqcHJvbWlzZSogd2l0aCB0aGUgc3RhbGUgdmFsdWUsXG4gICAgICAgICAgLy8gc2luY2Ugd2UgYXJlIGRvbmUgd2l0aCB0aGUgcHJvbWlzZSBhdCB0aGlzIHBvaW50LlxuICAgICAgICAgIC8vIGxlYXZlIGl0IHVudG91Y2hlZCBpZiB3ZSdyZSBzdGlsbCB3YWl0aW5nIGZvciBhblxuICAgICAgICAgIC8vIGFib3J0ZWQgYmFja2dyb3VuZCBmZXRjaCB0aGF0IGhhc24ndCB5ZXQgcmV0dXJuZWQuXG4gICAgICAgICAgdGhpcy52YWxMaXN0W2luZGV4XSA9IHAuX19zdGFsZVdoaWxlRmV0Y2hpbmdcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGFsbG93U3RhbGUpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuc3RhdHVzICYmIHAuX19zdGFsZVdoaWxlRmV0Y2hpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG9wdGlvbnMuc3RhdHVzLnJldHVybmVkU3RhbGUgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHAuX19zdGFsZVdoaWxlRmV0Y2hpbmdcbiAgICAgIH0gZWxzZSBpZiAocC5fX3JldHVybmVkID09PSBwKSB7XG4gICAgICAgIHRocm93IGVyXG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHBjYWxsID0gKHJlcywgcmVqKSA9PiB7XG4gICAgICB0aGlzLmZldGNoTWV0aG9kKGssIHYsIGZldGNoT3B0cykudGhlbih2ID0+IHJlcyh2KSwgcmVqKVxuICAgICAgLy8gaWdub3JlZCwgd2UgZ28gdW50aWwgd2UgZmluaXNoLCByZWdhcmRsZXNzLlxuICAgICAgLy8gZGVmZXIgY2hlY2sgdW50aWwgd2UgYXJlIGFjdHVhbGx5IGFib3J0aW5nLFxuICAgICAgLy8gc28gZmV0Y2hNZXRob2QgY2FuIG92ZXJyaWRlLlxuICAgICAgYWMuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4ge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIW9wdGlvbnMuaWdub3JlRmV0Y2hBYm9ydCB8fFxuICAgICAgICAgIG9wdGlvbnMuYWxsb3dTdGFsZU9uRmV0Y2hBYm9ydFxuICAgICAgICApIHtcbiAgICAgICAgICByZXMoKVxuICAgICAgICAgIC8vIHdoZW4gaXQgZXZlbnR1YWxseSByZXNvbHZlcywgdXBkYXRlIHRoZSBjYWNoZS5cbiAgICAgICAgICBpZiAob3B0aW9ucy5hbGxvd1N0YWxlT25GZXRjaEFib3J0KSB7XG4gICAgICAgICAgICByZXMgPSB2ID0+IGNiKHYsIHRydWUpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zdGF0dXMpIG9wdGlvbnMuc3RhdHVzLmZldGNoRGlzcGF0Y2hlZCA9IHRydWVcbiAgICBjb25zdCBwID0gbmV3IFByb21pc2UocGNhbGwpLnRoZW4oY2IsIGViKVxuICAgIHAuX19hYm9ydENvbnRyb2xsZXIgPSBhY1xuICAgIHAuX19zdGFsZVdoaWxlRmV0Y2hpbmcgPSB2XG4gICAgcC5fX3JldHVybmVkID0gbnVsbFxuICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBpbnRlcm5hbCwgZG9uJ3QgZXhwb3NlIHN0YXR1cy5cbiAgICAgIHRoaXMuc2V0KGssIHAsIHsgLi4uZmV0Y2hPcHRzLm9wdGlvbnMsIHN0YXR1czogdW5kZWZpbmVkIH0pXG4gICAgICBpbmRleCA9IHRoaXMua2V5TWFwLmdldChrKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnZhbExpc3RbaW5kZXhdID0gcFxuICAgIH1cbiAgICByZXR1cm4gcFxuICB9XG5cbiAgaXNCYWNrZ3JvdW5kRmV0Y2gocCkge1xuICAgIHJldHVybiAoXG4gICAgICBwICYmXG4gICAgICB0eXBlb2YgcCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIHR5cGVvZiBwLnRoZW4gPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChcbiAgICAgICAgcCxcbiAgICAgICAgJ19fc3RhbGVXaGlsZUZldGNoaW5nJ1xuICAgICAgKSAmJlxuICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHAsICdfX3JldHVybmVkJykgJiZcbiAgICAgIChwLl9fcmV0dXJuZWQgPT09IHAgfHwgcC5fX3JldHVybmVkID09PSBudWxsKVxuICAgIClcbiAgfVxuXG4gIC8vIHRoaXMgdGFrZXMgdGhlIHVuaW9uIG9mIGdldCgpIGFuZCBzZXQoKSBvcHRzLCBiZWNhdXNlIGl0IGRvZXMgYm90aFxuICBhc3luYyBmZXRjaChcbiAgICBrLFxuICAgIHtcbiAgICAgIC8vIGdldCBvcHRpb25zXG4gICAgICBhbGxvd1N0YWxlID0gdGhpcy5hbGxvd1N0YWxlLFxuICAgICAgdXBkYXRlQWdlT25HZXQgPSB0aGlzLnVwZGF0ZUFnZU9uR2V0LFxuICAgICAgbm9EZWxldGVPblN0YWxlR2V0ID0gdGhpcy5ub0RlbGV0ZU9uU3RhbGVHZXQsXG4gICAgICAvLyBzZXQgb3B0aW9uc1xuICAgICAgdHRsID0gdGhpcy50dGwsXG4gICAgICBub0Rpc3Bvc2VPblNldCA9IHRoaXMubm9EaXNwb3NlT25TZXQsXG4gICAgICBzaXplID0gMCxcbiAgICAgIHNpemVDYWxjdWxhdGlvbiA9IHRoaXMuc2l6ZUNhbGN1bGF0aW9uLFxuICAgICAgbm9VcGRhdGVUVEwgPSB0aGlzLm5vVXBkYXRlVFRMLFxuICAgICAgLy8gZmV0Y2ggZXhjbHVzaXZlIG9wdGlvbnNcbiAgICAgIG5vRGVsZXRlT25GZXRjaFJlamVjdGlvbiA9IHRoaXMubm9EZWxldGVPbkZldGNoUmVqZWN0aW9uLFxuICAgICAgYWxsb3dTdGFsZU9uRmV0Y2hSZWplY3Rpb24gPSB0aGlzLmFsbG93U3RhbGVPbkZldGNoUmVqZWN0aW9uLFxuICAgICAgaWdub3JlRmV0Y2hBYm9ydCA9IHRoaXMuaWdub3JlRmV0Y2hBYm9ydCxcbiAgICAgIGFsbG93U3RhbGVPbkZldGNoQWJvcnQgPSB0aGlzLmFsbG93U3RhbGVPbkZldGNoQWJvcnQsXG4gICAgICBmZXRjaENvbnRleHQgPSB0aGlzLmZldGNoQ29udGV4dCxcbiAgICAgIGZvcmNlUmVmcmVzaCA9IGZhbHNlLFxuICAgICAgc3RhdHVzLFxuICAgICAgc2lnbmFsLFxuICAgIH0gPSB7fVxuICApIHtcbiAgICBpZiAoIXRoaXMuZmV0Y2hNZXRob2QpIHtcbiAgICAgIGlmIChzdGF0dXMpIHN0YXR1cy5mZXRjaCA9ICdnZXQnXG4gICAgICByZXR1cm4gdGhpcy5nZXQoaywge1xuICAgICAgICBhbGxvd1N0YWxlLFxuICAgICAgICB1cGRhdGVBZ2VPbkdldCxcbiAgICAgICAgbm9EZWxldGVPblN0YWxlR2V0LFxuICAgICAgICBzdGF0dXMsXG4gICAgICB9KVxuICAgIH1cblxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBhbGxvd1N0YWxlLFxuICAgICAgdXBkYXRlQWdlT25HZXQsXG4gICAgICBub0RlbGV0ZU9uU3RhbGVHZXQsXG4gICAgICB0dGwsXG4gICAgICBub0Rpc3Bvc2VPblNldCxcbiAgICAgIHNpemUsXG4gICAgICBzaXplQ2FsY3VsYXRpb24sXG4gICAgICBub1VwZGF0ZVRUTCxcbiAgICAgIG5vRGVsZXRlT25GZXRjaFJlamVjdGlvbixcbiAgICAgIGFsbG93U3RhbGVPbkZldGNoUmVqZWN0aW9uLFxuICAgICAgYWxsb3dTdGFsZU9uRmV0Y2hBYm9ydCxcbiAgICAgIGlnbm9yZUZldGNoQWJvcnQsXG4gICAgICBzdGF0dXMsXG4gICAgICBzaWduYWwsXG4gICAgfVxuXG4gICAgbGV0IGluZGV4ID0gdGhpcy5rZXlNYXAuZ2V0KGspXG4gICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChzdGF0dXMpIHN0YXR1cy5mZXRjaCA9ICdtaXNzJ1xuICAgICAgY29uc3QgcCA9IHRoaXMuYmFja2dyb3VuZEZldGNoKGssIGluZGV4LCBvcHRpb25zLCBmZXRjaENvbnRleHQpXG4gICAgICByZXR1cm4gKHAuX19yZXR1cm5lZCA9IHApXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGluIGNhY2hlLCBtYXliZSBhbHJlYWR5IGZldGNoaW5nXG4gICAgICBjb25zdCB2ID0gdGhpcy52YWxMaXN0W2luZGV4XVxuICAgICAgaWYgKHRoaXMuaXNCYWNrZ3JvdW5kRmV0Y2godikpIHtcbiAgICAgICAgY29uc3Qgc3RhbGUgPVxuICAgICAgICAgIGFsbG93U3RhbGUgJiYgdi5fX3N0YWxlV2hpbGVGZXRjaGluZyAhPT0gdW5kZWZpbmVkXG4gICAgICAgIGlmIChzdGF0dXMpIHtcbiAgICAgICAgICBzdGF0dXMuZmV0Y2ggPSAnaW5mbGlnaHQnXG4gICAgICAgICAgaWYgKHN0YWxlKSBzdGF0dXMucmV0dXJuZWRTdGFsZSA9IHRydWVcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhbGUgPyB2Ll9fc3RhbGVXaGlsZUZldGNoaW5nIDogKHYuX19yZXR1cm5lZCA9IHYpXG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHdlIGZvcmNlIGEgcmVmcmVzaCwgdGhhdCBtZWFucyBkbyBOT1Qgc2VydmUgdGhlIGNhY2hlZCB2YWx1ZSxcbiAgICAgIC8vIHVubGVzcyB3ZSBhcmUgYWxyZWFkeSBpbiB0aGUgcHJvY2VzcyBvZiByZWZyZXNoaW5nIHRoZSBjYWNoZS5cbiAgICAgIGNvbnN0IGlzU3RhbGUgPSB0aGlzLmlzU3RhbGUoaW5kZXgpXG4gICAgICBpZiAoIWZvcmNlUmVmcmVzaCAmJiAhaXNTdGFsZSkge1xuICAgICAgICBpZiAoc3RhdHVzKSBzdGF0dXMuZmV0Y2ggPSAnaGl0J1xuICAgICAgICB0aGlzLm1vdmVUb1RhaWwoaW5kZXgpXG4gICAgICAgIGlmICh1cGRhdGVBZ2VPbkdldCkge1xuICAgICAgICAgIHRoaXMudXBkYXRlSXRlbUFnZShpbmRleClcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXR1c1RUTChzdGF0dXMsIGluZGV4KVxuICAgICAgICByZXR1cm4gdlxuICAgICAgfVxuXG4gICAgICAvLyBvaywgaXQgaXMgc3RhbGUgb3IgYSBmb3JjZWQgcmVmcmVzaCwgYW5kIG5vdCBhbHJlYWR5IGZldGNoaW5nLlxuICAgICAgLy8gcmVmcmVzaCB0aGUgY2FjaGUuXG4gICAgICBjb25zdCBwID0gdGhpcy5iYWNrZ3JvdW5kRmV0Y2goaywgaW5kZXgsIG9wdGlvbnMsIGZldGNoQ29udGV4dClcbiAgICAgIGNvbnN0IGhhc1N0YWxlID0gcC5fX3N0YWxlV2hpbGVGZXRjaGluZyAhPT0gdW5kZWZpbmVkXG4gICAgICBjb25zdCBzdGFsZVZhbCA9IGhhc1N0YWxlICYmIGFsbG93U3RhbGVcbiAgICAgIGlmIChzdGF0dXMpIHtcbiAgICAgICAgc3RhdHVzLmZldGNoID0gaGFzU3RhbGUgJiYgaXNTdGFsZSA/ICdzdGFsZScgOiAncmVmcmVzaCdcbiAgICAgICAgaWYgKHN0YWxlVmFsICYmIGlzU3RhbGUpIHN0YXR1cy5yZXR1cm5lZFN0YWxlID0gdHJ1ZVxuICAgICAgfVxuICAgICAgcmV0dXJuIHN0YWxlVmFsID8gcC5fX3N0YWxlV2hpbGVGZXRjaGluZyA6IChwLl9fcmV0dXJuZWQgPSBwKVxuICAgIH1cbiAgfVxuXG4gIGdldChcbiAgICBrLFxuICAgIHtcbiAgICAgIGFsbG93U3RhbGUgPSB0aGlzLmFsbG93U3RhbGUsXG4gICAgICB1cGRhdGVBZ2VPbkdldCA9IHRoaXMudXBkYXRlQWdlT25HZXQsXG4gICAgICBub0RlbGV0ZU9uU3RhbGVHZXQgPSB0aGlzLm5vRGVsZXRlT25TdGFsZUdldCxcbiAgICAgIHN0YXR1cyxcbiAgICB9ID0ge31cbiAgKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmtleU1hcC5nZXQoaylcbiAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnZhbExpc3RbaW5kZXhdXG4gICAgICBjb25zdCBmZXRjaGluZyA9IHRoaXMuaXNCYWNrZ3JvdW5kRmV0Y2godmFsdWUpXG4gICAgICB0aGlzLnN0YXR1c1RUTChzdGF0dXMsIGluZGV4KVxuICAgICAgaWYgKHRoaXMuaXNTdGFsZShpbmRleCkpIHtcbiAgICAgICAgaWYgKHN0YXR1cykgc3RhdHVzLmdldCA9ICdzdGFsZSdcbiAgICAgICAgLy8gZGVsZXRlIG9ubHkgaWYgbm90IGFuIGluLWZsaWdodCBiYWNrZ3JvdW5kIGZldGNoXG4gICAgICAgIGlmICghZmV0Y2hpbmcpIHtcbiAgICAgICAgICBpZiAoIW5vRGVsZXRlT25TdGFsZUdldCkge1xuICAgICAgICAgICAgdGhpcy5kZWxldGUoaylcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXR1cykgc3RhdHVzLnJldHVybmVkU3RhbGUgPSBhbGxvd1N0YWxlXG4gICAgICAgICAgcmV0dXJuIGFsbG93U3RhbGUgPyB2YWx1ZSA6IHVuZGVmaW5lZFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzdGF0dXMpIHtcbiAgICAgICAgICAgIHN0YXR1cy5yZXR1cm5lZFN0YWxlID1cbiAgICAgICAgICAgICAgYWxsb3dTdGFsZSAmJiB2YWx1ZS5fX3N0YWxlV2hpbGVGZXRjaGluZyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhbGxvd1N0YWxlID8gdmFsdWUuX19zdGFsZVdoaWxlRmV0Y2hpbmcgOiB1bmRlZmluZWRcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHN0YXR1cykgc3RhdHVzLmdldCA9ICdoaXQnXG4gICAgICAgIC8vIGlmIHdlJ3JlIGN1cnJlbnRseSBmZXRjaGluZyBpdCwgd2UgZG9uJ3QgYWN0dWFsbHkgaGF2ZSBpdCB5ZXRcbiAgICAgICAgLy8gaXQncyBub3Qgc3RhbGUsIHdoaWNoIG1lYW5zIHRoaXMgaXNuJ3QgYSBzdGFsZVdoaWxlUmVmZXRjaGluZy5cbiAgICAgICAgLy8gSWYgaXQncyBub3Qgc3RhbGUsIGFuZCBmZXRjaGluZywgQU5EIGhhcyBhIF9fc3RhbGVXaGlsZUZldGNoaW5nXG4gICAgICAgIC8vIHZhbHVlLCB0aGVuIHRoYXQgbWVhbnMgdGhlIHVzZXIgZmV0Y2hlZCB3aXRoIHtmb3JjZVJlZnJlc2g6dHJ1ZX0sXG4gICAgICAgIC8vIHNvIGl0J3Mgc2FmZSB0byByZXR1cm4gdGhhdCB2YWx1ZS5cbiAgICAgICAgaWYgKGZldGNoaW5nKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlLl9fc3RhbGVXaGlsZUZldGNoaW5nXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb3ZlVG9UYWlsKGluZGV4KVxuICAgICAgICBpZiAodXBkYXRlQWdlT25HZXQpIHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZUl0ZW1BZ2UoaW5kZXgpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzdGF0dXMpIHtcbiAgICAgIHN0YXR1cy5nZXQgPSAnbWlzcydcbiAgICB9XG4gIH1cblxuICBjb25uZWN0KHAsIG4pIHtcbiAgICB0aGlzLnByZXZbbl0gPSBwXG4gICAgdGhpcy5uZXh0W3BdID0gblxuICB9XG5cbiAgbW92ZVRvVGFpbChpbmRleCkge1xuICAgIC8vIGlmIHRhaWwgYWxyZWFkeSwgbm90aGluZyB0byBkb1xuICAgIC8vIGlmIGhlYWQsIG1vdmUgaGVhZCB0byBuZXh0W2luZGV4XVxuICAgIC8vIGVsc2VcbiAgICAvLyAgIG1vdmUgbmV4dFtwcmV2W2luZGV4XV0gdG8gbmV4dFtpbmRleF0gKGhlYWQgaGFzIG5vIHByZXYpXG4gICAgLy8gICBtb3ZlIHByZXZbbmV4dFtpbmRleF1dIHRvIHByZXZbaW5kZXhdXG4gICAgLy8gcHJldltpbmRleF0gPSB0YWlsXG4gICAgLy8gbmV4dFt0YWlsXSA9IGluZGV4XG4gICAgLy8gdGFpbCA9IGluZGV4XG4gICAgaWYgKGluZGV4ICE9PSB0aGlzLnRhaWwpIHtcbiAgICAgIGlmIChpbmRleCA9PT0gdGhpcy5oZWFkKSB7XG4gICAgICAgIHRoaXMuaGVhZCA9IHRoaXMubmV4dFtpbmRleF1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29ubmVjdCh0aGlzLnByZXZbaW5kZXhdLCB0aGlzLm5leHRbaW5kZXhdKVxuICAgICAgfVxuICAgICAgdGhpcy5jb25uZWN0KHRoaXMudGFpbCwgaW5kZXgpXG4gICAgICB0aGlzLnRhaWwgPSBpbmRleFxuICAgIH1cbiAgfVxuXG4gIGdldCBkZWwoKSB7XG4gICAgZGVwcmVjYXRlZE1ldGhvZCgnZGVsJywgJ2RlbGV0ZScpXG4gICAgcmV0dXJuIHRoaXMuZGVsZXRlXG4gIH1cblxuICBkZWxldGUoaykge1xuICAgIGxldCBkZWxldGVkID0gZmFsc2VcbiAgICBpZiAodGhpcy5zaXplICE9PSAwKSB7XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMua2V5TWFwLmdldChrKVxuICAgICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVsZXRlZCA9IHRydWVcbiAgICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gMSkge1xuICAgICAgICAgIHRoaXMuY2xlYXIoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmVtb3ZlSXRlbVNpemUoaW5kZXgpXG4gICAgICAgICAgY29uc3QgdiA9IHRoaXMudmFsTGlzdFtpbmRleF1cbiAgICAgICAgICBpZiAodGhpcy5pc0JhY2tncm91bmRGZXRjaCh2KSkge1xuICAgICAgICAgICAgdi5fX2Fib3J0Q29udHJvbGxlci5hYm9ydChuZXcgRXJyb3IoJ2RlbGV0ZWQnKSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NlKHYsIGssICdkZWxldGUnKVxuICAgICAgICAgICAgaWYgKHRoaXMuZGlzcG9zZUFmdGVyKSB7XG4gICAgICAgICAgICAgIHRoaXMuZGlzcG9zZWQucHVzaChbdiwgaywgJ2RlbGV0ZSddKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmtleU1hcC5kZWxldGUoaylcbiAgICAgICAgICB0aGlzLmtleUxpc3RbaW5kZXhdID0gbnVsbFxuICAgICAgICAgIHRoaXMudmFsTGlzdFtpbmRleF0gPSBudWxsXG4gICAgICAgICAgaWYgKGluZGV4ID09PSB0aGlzLnRhaWwpIHtcbiAgICAgICAgICAgIHRoaXMudGFpbCA9IHRoaXMucHJldltpbmRleF1cbiAgICAgICAgICB9IGVsc2UgaWYgKGluZGV4ID09PSB0aGlzLmhlYWQpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHRoaXMubmV4dFtpbmRleF1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5uZXh0W3RoaXMucHJldltpbmRleF1dID0gdGhpcy5uZXh0W2luZGV4XVxuICAgICAgICAgICAgdGhpcy5wcmV2W3RoaXMubmV4dFtpbmRleF1dID0gdGhpcy5wcmV2W2luZGV4XVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnNpemUtLVxuICAgICAgICAgIHRoaXMuZnJlZS5wdXNoKGluZGV4KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmRpc3Bvc2VkKSB7XG4gICAgICB3aGlsZSAodGhpcy5kaXNwb3NlZC5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5kaXNwb3NlQWZ0ZXIoLi4udGhpcy5kaXNwb3NlZC5zaGlmdCgpKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVsZXRlZFxuICB9XG5cbiAgY2xlYXIoKSB7XG4gICAgZm9yIChjb25zdCBpbmRleCBvZiB0aGlzLnJpbmRleGVzKHsgYWxsb3dTdGFsZTogdHJ1ZSB9KSkge1xuICAgICAgY29uc3QgdiA9IHRoaXMudmFsTGlzdFtpbmRleF1cbiAgICAgIGlmICh0aGlzLmlzQmFja2dyb3VuZEZldGNoKHYpKSB7XG4gICAgICAgIHYuX19hYm9ydENvbnRyb2xsZXIuYWJvcnQobmV3IEVycm9yKCdkZWxldGVkJykpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBrID0gdGhpcy5rZXlMaXN0W2luZGV4XVxuICAgICAgICB0aGlzLmRpc3Bvc2UodiwgaywgJ2RlbGV0ZScpXG4gICAgICAgIGlmICh0aGlzLmRpc3Bvc2VBZnRlcikge1xuICAgICAgICAgIHRoaXMuZGlzcG9zZWQucHVzaChbdiwgaywgJ2RlbGV0ZSddKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5rZXlNYXAuY2xlYXIoKVxuICAgIHRoaXMudmFsTGlzdC5maWxsKG51bGwpXG4gICAgdGhpcy5rZXlMaXN0LmZpbGwobnVsbClcbiAgICBpZiAodGhpcy50dGxzKSB7XG4gICAgICB0aGlzLnR0bHMuZmlsbCgwKVxuICAgICAgdGhpcy5zdGFydHMuZmlsbCgwKVxuICAgIH1cbiAgICBpZiAodGhpcy5zaXplcykge1xuICAgICAgdGhpcy5zaXplcy5maWxsKDApXG4gICAgfVxuICAgIHRoaXMuaGVhZCA9IDBcbiAgICB0aGlzLnRhaWwgPSAwXG4gICAgdGhpcy5pbml0aWFsRmlsbCA9IDFcbiAgICB0aGlzLmZyZWUubGVuZ3RoID0gMFxuICAgIHRoaXMuY2FsY3VsYXRlZFNpemUgPSAwXG4gICAgdGhpcy5zaXplID0gMFxuICAgIGlmICh0aGlzLmRpc3Bvc2VkKSB7XG4gICAgICB3aGlsZSAodGhpcy5kaXNwb3NlZC5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5kaXNwb3NlQWZ0ZXIoLi4udGhpcy5kaXNwb3NlZC5zaGlmdCgpKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldCByZXNldCgpIHtcbiAgICBkZXByZWNhdGVkTWV0aG9kKCdyZXNldCcsICdjbGVhcicpXG4gICAgcmV0dXJuIHRoaXMuY2xlYXJcbiAgfVxuXG4gIGdldCBsZW5ndGgoKSB7XG4gICAgZGVwcmVjYXRlZFByb3BlcnR5KCdsZW5ndGgnLCAnc2l6ZScpXG4gICAgcmV0dXJuIHRoaXMuc2l6ZVxuICB9XG5cbiAgc3RhdGljIGdldCBBYm9ydENvbnRyb2xsZXIoKSB7XG4gICAgcmV0dXJuIEFDXG4gIH1cbiAgc3RhdGljIGdldCBBYm9ydFNpZ25hbCgpIHtcbiAgICByZXR1cm4gQVNcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IExSVUNhY2hlXG4iXSwibmFtZXMiOlsicGVyZiIsInBlcmZvcm1hbmNlIiwibm93IiwiRGF0ZSIsImhhc0Fib3J0Q29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsIkFDIiwiY29uc3RydWN0b3IiLCJzaWduYWwiLCJBUyIsImFib3J0IiwicmVhc29uIiwiRXJyb3IiLCJhYm9ydGVkIiwiZGlzcGF0Y2hFdmVudCIsInR5cGUiLCJ0YXJnZXQiLCJoYXNBYm9ydFNpZ25hbCIsIkFib3J0U2lnbmFsIiwiaGFzQUNBYm9ydFNpZ25hbCIsInVuZGVmaW5lZCIsIl9saXN0ZW5lcnMiLCJlIiwib25hYm9ydCIsImZvckVhY2giLCJmIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2IiwiZm4iLCJwdXNoIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImZpbHRlciIsIndhcm5lZCIsIlNldCIsImRlcHJlY2F0ZWRPcHRpb24iLCJvcHQiLCJpbnN0ZWFkIiwiY29kZSIsInNob3VsZFdhcm4iLCJ3YXJuIiwiTFJVQ2FjaGUiLCJkZXByZWNhdGVkTWV0aG9kIiwibWV0aG9kIiwicHJvdG90eXBlIiwiZ2V0IiwiT2JqZWN0IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZGVwcmVjYXRlZFByb3BlcnR5IiwiZmllbGQiLCJlbWl0V2FybmluZyIsImEiLCJwcm9jZXNzIiwiY29uc29sZSIsImVycm9yIiwiaGFzIiwid2hhdCIsImFkZCIsIm1zZyIsImlzUG9zSW50IiwibiIsIk1hdGgiLCJmbG9vciIsImlzRmluaXRlIiwiZ2V0VWludEFycmF5IiwibWF4IiwicG93IiwiVWludDhBcnJheSIsIlVpbnQxNkFycmF5IiwiVWludDMyQXJyYXkiLCJOdW1iZXIiLCJNQVhfU0FGRV9JTlRFR0VSIiwiWmVyb0FycmF5IiwiQXJyYXkiLCJzaXplIiwiZmlsbCIsIlN0YWNrIiwiVWludEFycmF5IiwiaGVhcCIsImxlbmd0aCIsInBvcCIsIm9wdGlvbnMiLCJ0dGwiLCJ0dGxSZXNvbHV0aW9uIiwidHRsQXV0b3B1cmdlIiwidXBkYXRlQWdlT25HZXQiLCJ1cGRhdGVBZ2VPbkhhcyIsImFsbG93U3RhbGUiLCJkaXNwb3NlIiwiZGlzcG9zZUFmdGVyIiwibm9EaXNwb3NlT25TZXQiLCJub1VwZGF0ZVRUTCIsIm1heFNpemUiLCJtYXhFbnRyeVNpemUiLCJzaXplQ2FsY3VsYXRpb24iLCJmZXRjaE1ldGhvZCIsImZldGNoQ29udGV4dCIsIm5vRGVsZXRlT25GZXRjaFJlamVjdGlvbiIsIm5vRGVsZXRlT25TdGFsZUdldCIsImFsbG93U3RhbGVPbkZldGNoUmVqZWN0aW9uIiwiYWxsb3dTdGFsZU9uRmV0Y2hBYm9ydCIsImlnbm9yZUZldGNoQWJvcnQiLCJtYXhBZ2UiLCJzdGFsZSIsIlR5cGVFcnJvciIsImtleU1hcCIsIk1hcCIsImtleUxpc3QiLCJ2YWxMaXN0IiwibmV4dCIsInByZXYiLCJoZWFkIiwidGFpbCIsImZyZWUiLCJpbml0aWFsRmlsbCIsImRpc3Bvc2VkIiwiaW5pdGlhbGl6ZVNpemVUcmFja2luZyIsImluaXRpYWxpemVUVExUcmFja2luZyIsImdldFJlbWFpbmluZ1RUTCIsImtleSIsIkluZmluaXR5IiwidHRscyIsInN0YXJ0cyIsInNldEl0ZW1UVEwiLCJpbmRleCIsInN0YXJ0IiwidCIsInNldFRpbWVvdXQiLCJpc1N0YWxlIiwiZGVsZXRlIiwidW5yZWYiLCJ1cGRhdGVJdGVtQWdlIiwic3RhdHVzVFRMIiwic3RhdHVzIiwiY2FjaGVkTm93IiwiZ2V0Tm93IiwicmVtYWluaW5nVFRMIiwiX2luZGV4IiwiX3N0YXR1cyIsIl90dGwiLCJfc3RhcnQiLCJjYWxjdWxhdGVkU2l6ZSIsInNpemVzIiwicmVtb3ZlSXRlbVNpemUiLCJyZXF1aXJlU2l6ZSIsImsiLCJ2IiwiaXNCYWNrZ3JvdW5kRmV0Y2giLCJhZGRJdGVtU2l6ZSIsImV2aWN0IiwiZW50cnlTaXplIiwidG90YWxDYWxjdWxhdGVkU2l6ZSIsIl9zaXplIiwiX2siLCJfdiIsImluZGV4ZXMiLCJpIiwiaXNWYWxpZEluZGV4IiwicmluZGV4ZXMiLCJlbnRyaWVzIiwicmVudHJpZXMiLCJrZXlzIiwicmtleXMiLCJ2YWx1ZXMiLCJydmFsdWVzIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJmaW5kIiwiZ2V0T3B0aW9ucyIsInZhbHVlIiwiX19zdGFsZVdoaWxlRmV0Y2hpbmciLCJ0aGlzcCIsImNhbGwiLCJyZm9yRWFjaCIsInBydW5lIiwicHVyZ2VTdGFsZSIsImRlbGV0ZWQiLCJkdW1wIiwiYXJyIiwiZW50cnkiLCJhZ2UiLCJ1bnNoaWZ0IiwibG9hZCIsImNsZWFyIiwic2V0IiwiX3JlYXNvbiIsIm1heEVudHJ5U2l6ZUV4Y2VlZGVkIiwibmV3SW5kZXgiLCJtb3ZlVG9UYWlsIiwib2xkVmFsIiwiX19hYm9ydENvbnRyb2xsZXIiLCJvbGRWYWx1ZSIsInNoaWZ0IiwidmFsIiwicGVlayIsImJhY2tncm91bmRGZXRjaCIsImNvbnRleHQiLCJhYyIsImZldGNoT3B0cyIsImNiIiwidXBkYXRlQ2FjaGUiLCJpZ25vcmVBYm9ydCIsImZldGNoQWJvcnRlZCIsImZldGNoRXJyb3IiLCJmZXRjaEFib3J0SWdub3JlZCIsImZldGNoUmVzb2x2ZWQiLCJmZXRjaEZhaWwiLCJwIiwiZmV0Y2hVcGRhdGVkIiwiZWIiLCJlciIsImZldGNoUmVqZWN0ZWQiLCJhbGxvd1N0YWxlQWJvcnRlZCIsIm5vRGVsZXRlIiwiZGVsIiwicmV0dXJuZWRTdGFsZSIsIl9fcmV0dXJuZWQiLCJwY2FsbCIsInJlcyIsInJlaiIsInRoZW4iLCJmZXRjaERpc3BhdGNoZWQiLCJQcm9taXNlIiwiaGFzT3duUHJvcGVydHkiLCJmZXRjaCIsImZvcmNlUmVmcmVzaCIsImhhc1N0YWxlIiwic3RhbGVWYWwiLCJmZXRjaGluZyIsImNvbm5lY3QiLCJyZXNldCIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBLE1BQU1BLE9BQ0osT0FBT0MsZ0JBQWdCLFlBQ3ZCQSxlQUNBLE9BQU9BLFlBQVlDLEdBQUcsS0FBSyxhQUN2QkQsY0FDQUU7QUFFTixNQUFNQyxxQkFBcUIsT0FBT0Msb0JBQW9CO0FBRXRELDJDQUEyQztBQUMzQywyREFBMkQ7QUFDM0QseURBQXlEO0FBQ3pELHdEQUF3RDtBQUN4RCxNQUFNQyxLQUFLRixxQkFDUEMsa0JBQ0EsTUFBTUE7SUFDSkUsYUFBYztRQUNaLElBQUksQ0FBQ0MsTUFBTSxHQUFHLElBQUlDO0lBQ3BCO0lBQ0FDLE1BQU1DLFNBQVMsSUFBSUMsTUFBTSw2QkFBNkIsRUFBRTtRQUN0RCxJQUFJLENBQUNKLE1BQU0sQ0FBQ0csTUFBTSxHQUFHLElBQUksQ0FBQ0gsTUFBTSxDQUFDRyxNQUFNLElBQUlBO1FBQzNDLElBQUksQ0FBQ0gsTUFBTSxDQUFDSyxPQUFPLEdBQUc7UUFDdEIsSUFBSSxDQUFDTCxNQUFNLENBQUNNLGFBQWEsQ0FBQztZQUN4QkMsTUFBTTtZQUNOQyxRQUFRLElBQUksQ0FBQ1IsTUFBTTtRQUNyQjtJQUNGO0FBQ0Y7QUFFSixNQUFNUyxpQkFBaUIsT0FBT0MsZ0JBQWdCO0FBQzlDLHNEQUFzRDtBQUN0RCxNQUFNQyxtQkFBbUIsT0FBT2IsR0FBR1ksV0FBVyxLQUFLO0FBQ25ELE1BQU1ULEtBQUtRLGlCQUNQQyxjQUNBQyxtQkFDQWIsR0FBR0QsZUFBZSxHQUNsQixNQUFNYTtJQUNKWCxhQUFjO1FBQ1osSUFBSSxDQUFDSSxNQUFNLEdBQUdTO1FBQ2QsSUFBSSxDQUFDUCxPQUFPLEdBQUc7UUFDZixJQUFJLENBQUNRLFVBQVUsR0FBRyxFQUFFO0lBQ3RCO0lBQ0FQLGNBQWNRLENBQUMsRUFBRTtRQUNmLElBQUlBLEVBQUVQLElBQUksS0FBSyxTQUFTO1lBQ3RCLElBQUksQ0FBQ0Ys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RSxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDRCxJQUFJLENBQUNsQyxNQUFNLEdBQUc7UUFDbkIsSUFBSSxDQUFDOEQsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ25FLElBQUksR0FBRztRQUNaLElBQUksSUFBSSxDQUFDeUMsUUFBUSxFQUFFO1lBQ2pCLE1BQU8sSUFBSSxDQUFDQSxRQUFRLENBQUNwQyxNQUFNLENBQUU7Z0JBQzNCLElBQUksQ0FBQ1UsWUFBWSxJQUFJLElBQUksQ0FBQzBCLFFBQVEsQ0FBQzZFLEtBQUs7WUFDMUM7UUFDRjtJQUNGO0lBRUEsSUFBSXNDLFFBQVE7UUFDVjVMLGlCQUFpQixTQUFTO1FBQzFCLE9BQU8sSUFBSSxDQUFDNkksS0FBSztJQUNuQjtJQUVBLElBQUl4RyxTQUFTO1FBQ1gvQixtQkFBbUIsVUFBVTtRQUM3QixPQUFPLElBQUksQ0FBQzBCLElBQUk7SUFDbEI7SUFFQSxXQUFXcEUsa0JBQWtCO1FBQzNCLE9BQU9DO0lBQ1Q7SUFDQSxXQUFXWSxjQUFjO1FBQ3ZCLE9BQU9UO0lBQ1Q7QUFDRjtBQUVBNk4sT0FBT0MsT0FBTyxHQUFHL0wiLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmFtZWQtcGxhY2Vob2xkZXJzL25vZGVfbW9kdWxlcy9scnUtY2FjaGUvaW5kZXguanMiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/named-placeholders/node_modules/lru-cache/index.js\n");

/***/ })

};
;